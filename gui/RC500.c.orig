#include <apparel.h>
#include "RC500.h"
#include "InitSystem.h"
#include "des.h"
#include "OnlineRecharge.h"
#include "../Display/fbtools.h"
#include "../sound/sound.h"

// 云南玉溪PBOC金融卡M1界面用户卡类扇区
#define YUXI_PBOC_USER_INFO_SECTOR	1

extern int mf_fd;
extern unsigned char DevSerialID[4];
extern unsigned char DayMaxCount;
//extern unsigned char FileOpenFlag;
extern unsigned char AutoUpFlag;
extern unsigned char SavedataErr;
extern unsigned char CardTwo;  //包月标志
extern unsigned char ReadCardFirst;

extern RouteJack TypeTime;
extern CardLanSector LanSec;   //用户扇区
extern FixTimerBuf FixTime;
extern LongUnon DevSID;
extern LongUnon TransactionNum;
extern LongUnon DecValue;
extern LongUnon HostValue;
extern LongUnon DevNum,DayMaxMoney;	//终端机机号
extern unsigned short SectionNum;

static LongUnon JackArm,Test,Buf;
unsigned char SnBack[4] = {0x26,0x91,0x13,0x00};
unsigned char XFBuf1[16],XFBuf2[16];
unsigned char BFlaglessfive;
//unsigned char CardModeFalg;
unsigned char KeyDes[8];	//密钥
struct card_buf  test;
CardInform CardLan;
JackRegal Sector;
JackValue MoneyNo;
SysTime Time;
SectionFarPar Section,Sectionup;
unsigned char CardTypeIC;

static unsigned int readcardnum = 0;
//static unsigned char IncDecFalg;

///////////////////////////////////////////////////////////
/*
#define  IDC_MESSGETMSG_TIMER   518
#define TIMEDISP(x)		((x >> 8 )&0x00ff)
#define TYPEDISP(x)		(x & 0x00ff)
static int semBox = -1;           						//此界面同时只能显示一次

static DLGTEMPLATE DlgMessboxwindow =
{
    WS_BORDER, WS_EX_NONE, 10, 10, 300, 220, "M-Box", 0, 0, 0, NULL,0
};

static CTRLDATA CtrlPopupwindow [] =
{
};
*/
/*****************************************
ASCII 到 HEX的转换函数
入口参数： O_data: 转换数据的入口指针
N_data: 转换后新数据的入口指针
len : 需要转换的长度
返回参数：-1: 转换失败
其它：转换后数据长度
注意：O_data[]数组中的数据在转换过程中会被修改。
****************************************/
int ascii_2_hex(unsigned char *O_data, unsigned char *N_data, int len)
{
	int i,j,tmp_len;
	unsigned char tmpData;
	unsigned char *O_buf = O_data;
	unsigned char *N_buf = N_data;
	for(i = 0; i < len; i++)
	{
		if ((O_buf[i] >= '0') && (O_buf[i] <= '9'))
		{
			tmpData = O_buf[i] - '0';
		}
		else if ((O_buf[i] >= 'A') && (O_buf[i] <= 'F')) //A....F
		{
			tmpData = O_buf[i] - 0x37;
		}
		else if((O_buf[i] >= 'a') && (O_buf[i] <= 'f')) //a....f
		{
			tmpData = O_buf[i] - 0x57;
		}
		else
		{
			//Uart_Printf(0,"i = %02X \r\n",i);
			return 0xff;
		}
		O_buf[i] = tmpData;
	}
	for(tmp_len = 0,j = 0; j < i; j+=2)
	{
		N_buf[tmp_len++] = (O_buf[j]<<4) | O_buf[j+1];
	}
	return tmp_len;
}

void myitoa(char *s, unsigned int n)
{
	char tmp, *str;
	if (!n) {
		*s++=0x30;
		*s=0;
		return;
	}
	for (str=s; n; *s++='0'+ n%10, n/=10);
	for (*s--=0,n=strlen(str); n/2; n-=2,\
	        tmp=*str,*str++=*s,*s--=tmp);
}
/*
*************************************************************************************************************
- 函数名称 : void MoneyValue(INT8U *OUT_Data,unsigned int Money)
- 函数说明 : 转换成金钱格式
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
void MoneyValue(unsigned char *OUT_Data,unsigned int Money)
{
	unsigned char wa,wb,wc,i;
	if(Money > 2147483647)
	{
		Money = ~ Money;
		Money ++;
		myitoa(OUT_Data, Money);
		if(Money < 10)
		{
			wa =  OUT_Data[0];
			OUT_Data[0] = '-';
			OUT_Data[1] = '0';
			OUT_Data[2] = '.';
			OUT_Data[3] = '0';
			OUT_Data[4] =  wa;
		}
		else if((Money >=10)&&(Money < 100))
		{
			wa =  OUT_Data[0];
			wb =  OUT_Data[1];
			OUT_Data[0] = '-';
			OUT_Data[1] = '0';
			OUT_Data[2] = '.';
			OUT_Data[3] =  wa;
			OUT_Data[4] =  wb;
		}
		else
		{
			wa = strlen(OUT_Data);
			wb =  OUT_Data[wa-2];
			wc =  OUT_Data[wa-1];
			OUT_Data[wa-2] = '.';
			OUT_Data[wa-1] =  wb;
			OUT_Data[wa]   =  wc;
			for(i = wa+1; i > 0; i--)
			{
				OUT_Data[i] = OUT_Data[i-1];
			}
			OUT_Data[0] = '-';
		}
		strcat(OUT_Data,"元");
	}
	else
	{
		myitoa(OUT_Data, Money);
		if(Money < 10)
		{
			wa =  OUT_Data[0];
			OUT_Data[0] = '0';
			OUT_Data[1] = '.';
			OUT_Data[2] = '0';
			OUT_Data[3] =  wa;
		}
		else if((Money >=10)&&(Money < 100))
		{
			wa =  OUT_Data[0];
			wb =  OUT_Data[1];
			OUT_Data[0] = '0';
			OUT_Data[1] = '.';
			OUT_Data[2] =  wa;
			OUT_Data[3] =  wb;
		}
		else
		{
			wa = strlen(OUT_Data);
			wb =  OUT_Data[wa-2];
			wc =  OUT_Data[wa-1];
			OUT_Data[wa-2] = '.';
			OUT_Data[wa-1] =  wb;
			OUT_Data[wa]   =  wc;
		}
		strcat(OUT_Data,"元");
	}
}


/*
*************************************************************************************************************
- 函数名称 : void Err_display (HWND hDlg,unsigned char Mode)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
void Err_display(unsigned int messcode)
{
	int musicIndex = 0;

	DBG_RC500_PRINTF("Err_display() is called, code = %d.\n", messcode);

	LEDL(1);
	SetColor(Mcolor);
	SetTextColor(Color_red);
	SetTextSize(32);
	switch(messcode)
	{
	case 1:
		TextOut(100 , 50, "卡片错误");
		TextOut(35 , 90,  "卡片有效期已过期");
		TextOut(100 , 130,"谢谢使用");
		break;
	case 2:
		TextOut( 100 , 30, "卡片错误");
		TextOut( 65  , 70, "卡片格式错误");//
		TextOut( 50 , 110, "或非本系统卡片");
		TextOut( 100 , 150,"谢谢使用");
		break;
	case 3:
		TextOut(100 , 50, "卡片错误");
		TextOut( 65 , 90, "钱包格式错误");
		TextOut(100 , 130,"谢谢使用");
		break;
	case 4:
		TextOut(100 , 50, "卡片错误");
		TextOut( 65 , 90, "钱包格式错误");
		TextOut(100 , 130,"谢谢使用");
		break;
	case 5:
		TextOut(100 , 50, "卡片错误");
		TextOut(10 , 90,  "卡片格式进程标志错误");
		TextOut(100 , 130,"谢谢使用");
		break;
	case 6:
		TextOut(100 , 50, "卡片错误");
		TextOut( 65 , 90, "现金钱包错误");
		TextOut(100 , 130,"谢谢使用");
		break;
	case 9:
		TextOut(100 , 30,  "时段错误");
		TextOut( 85 , 70,  "现在时间不");//在消费时段内
		TextOut( 70 , 110, "在消费时段内");
		TextOut(100 , 150, "谢谢使用");
		break;
	case 10:
		TextOut( 100 , 50, "卡片错误");
		TextOut( 25 , 90,  "此卡片为黑名单卡片");
		TextOut( 100 , 130,"谢谢使用");
		break;
	case 11:
		TextOut( 100 , 30, "卡片错误");
		TextOut( 85 , 70, "系统不支持");//
		TextOut( 85 , 110,"此卡类消费");//
		TextOut(100 , 150,"谢谢使用");//
		break;
	case 12:
		TextOut( 100 , 30, "交易失败");
		TextOut( 35 , 70,  "您的卡片金额不够");
		TextOut( 35 , 110, "支付本次消费金额");
		TextOut( 100 , 150,"谢谢使用");
		break;
	case 13:
		TextOut( 100 , 30, "交易失败");
		TextOut( 35 , 70,  "当前时段消费金额");
		TextOut( 35 , 110, "超过最大消费额度");
		TextOut( 100 , 150,"谢谢使用");
		break;
	case 14:
		TextOut( 100 , 30, "交易失败");
		TextOut( 35 , 70,  "当天消费金额总数");
		TextOut( 35 , 110, "超过最大消费额度");
		TextOut( 100 , 150,"谢谢使用");
		break;

	case 15:
		TextOut( 100 , 30, "交易失败");
		TextOut( 35 , 70,  "当月消费金额总数");
		TextOut( 35 , 110, "超过最大消费额度");
		TextOut( 100 , 150,"谢谢使用");
		break;

	case 16:
		TextOut( 100 , 50, "交易失败");
		TextOut( 85 , 90, "参数表错误");
		TextOut( 100 , 130,"谢谢使用");
		break;

	case 17:
		TextOut( 100 , 50, "交易失败");
		TextOut( 70 , 90, "包月时间己过");
		TextOut( 100 , 130,"谢谢使用");
		break;

	case 18:
		TextOut( 100 , 30, "交易失败");
		TextOut( 35 ,  70, "当天交易次数总数");
		TextOut( 35 , 110, "超过最大限制次数");
		TextOut( 100 , 150,"谢谢使用");
		break;

	case 20:
		TextOut( 100 , 50, "交易失败");
		TextOut( 70 , 90, "内存指针错误");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 21:
		TextOut( 100 , 50, "交易失败");
		TextOut( 70 , 90, "记录内存已满");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 22:
		TextOut( 100 , 50,"交易失败");
		TextOut( 10 , 90, "本卡在限制使用时间内");
		TextOut( 100 ,130,"谢谢使用");
		break;


	case 23:
		TextOut( 100 , 50,"交易失败");
		TextOut( 35 , 90, "验证消费密钥失败");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 50:
		TextOut( 100 , 50,"交易失败");
		TextOut( 65 , 90, "没有上车标志");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 51:
		TextOut( 100 , 50,"交易失败");
		TextOut( 85 , 90, "此卡已下车");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 60:
		TextOut( 100 , 50,"交易失败");
		TextOut( 10 , 90, "电子现金交易被拒绝");
		TextOut( 100 ,130,"谢谢使用");
		break;

	case 61:
		TextOut( 100 , 50,"交易失败");
		TextOut( 10 , 90, "脱机数据验证失败!");
		TextOut( 100 ,130,"谢谢使用");
		break;

	default:
		break;
	}

	beepopen(3);
	if(messcode < 9)
	{
		// 语音       无效卡
		musicIndex =  11;
		PlayMusic(musicIndex);
	}
	else
	{
		switch(messcode)
		{
		case 10:
			// 语音       非法卡
			musicIndex =  12;
			break;

		case 13:
		case 14:
		case 15:
			// 语音       消费超限
			musicIndex =  17;
			break;

		case 22:
		case 51:
			// 语音       请勿重复刷卡
			musicIndex =  16;
			break;

		case 11:
		case 17:
		case 18:
		case 23:
		case 50:
		case 60:
		case 61:
			// 语音       无效卡
			musicIndex =  11;
			break;
		case 12:
			// 语音       余额不足
			musicIndex =  13;
			break;

		default :
			break;
		}
		PlayMusic(musicIndex);
	}

	ioctl(mf_fd, RC531_HALT);
	sleep(3);

	LEDL(0);

	SetColor(Mcolor);
}



/*
*************************************************************************************************************
- 函数名称 : unsigned char  MoneyYes(unsigned char *Date)
- 函数说明 : 得到卡片信息
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char  MoneyYes(unsigned char *Date)
{
	unsigned char  status = 1;
	unsigned int ak0,ak1,ak2;
	LongUnon Buf;

	memcpy(Buf.longbuf,Date  ,4);
	ak0 = Buf.i;
	memcpy(Buf.longbuf,Date+4,4);
	ak1 = Buf.i;
	memcpy(Buf.longbuf,Date+8,4);
	ak2 = Buf.i;
	if((ak0 == ak2)&&(ak0 == ~ak1)&&(Date[12] == Date[14])&&(Date[13] == Date[15])&&((Date[12]^Date[13]) == 0xff)&&(ak0 < 0x7fffffff))status = 0;
	return status;
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char JudgeCsn(void)
- 函数说明 : 判断卡片号码的合法性能
- 输入参数 : 无
- 输出参数 : 二种情况
			0：表示卡片不是黑名单
			1：表示卡片已经是黑名单
*************************************************************************************************************
*/
unsigned char Card_JudgeCsn(void)
{
	unsigned int   Nuo;
	unsigned char  status;
	unsigned char  cardbuf[5];
	unsigned char  CJCbuf[12];
	memset(CJCbuf,0,sizeof(CJCbuf));
	memset(cardbuf,0,sizeof(cardbuf));
	memcpy(cardbuf,CardLan.CardCsnB,4);
	hex_2_ascii(cardbuf,CJCbuf,4);
	Nuo = myatoi(CJCbuf);
	status = Number(Nuo,2);
	return status;
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char Permissions (HWND hDlg)
- 函数说明 : 权限处理
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char Permissions (unsigned char Mode)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	DBG_RC500_PRINTF("Permissions() is called.\n");

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = TimeRange();				//当前有没有合法的消费时间段
			if(status != MI_OK)
			{
				TypeTime.TimeNum = status;
				step++;

#if DBG_RC500
				printf("TypeTime = %d\n",TypeTime.TimeNum);
#endif

			}
			else
			{
				Err_display(9);
				Loop = 0;
			}
			break;


		case 2:		//判断卡片是否是黑名单卡 33表示卡是黑名单
			status  = Card_JudgeCsn();
			if(status == MI_OK)step++;
			else
			{
				Err_display(10);
				Loop = 0;
			}
			break;

		case 3:	//判断卡片类别
			status  = SupportType();
			if(status == MI_OK)step++;
			else
			{
				Err_display(11);
				Loop = 0;
			}
			break;

		case 4:
			if(SavedataErr == 0)step++;
			else if(SavedataErr == 2)
			{
				Err_display(21);
				Loop = 0;
			}
			else
			{
				Err_display(20);
				Loop = 0;
			}
			break;

		case 5:
			status = CardDiscounts(CardLan.CardType,Mode);
			if(status != MI_OK)step++;
			else
			{
				Err_display(22);
				Loop = 0;
			}
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}
	return(step);
}




/*
*************************************************************************************************************
- 函数名称 : void IncSerId (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
void IncSerId (void)
{
	DevSID.i ++;
	//while (FileOpenFlag == 0);
	// FileOpenFlag = 0;
	ReadOrWriteFile (DEVSERIALID);
	// FileOpenFlag = 1;
}

/*
*************************************************************************************************************
- 函数名称 : void IncTransactionNum (void)
- 函数说明 : 增加总交易次数
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
void IncTransactionNum (void)
{
	TransactionNum.i ++;
	//while (FileOpenFlag == 0);
	// FileOpenFlag = 0;
	ReadOrWriteFile(WSDATA);
	// FileOpenFlag = 1;
}

unsigned char DiverCard(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	while(Loop)
	{
		switch (step)
		{
		case 1: 						//有效日期是否可行
			status = Card_JudgeDate();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Err_display(1);
				Loop = 0;
			}
			break;

		case 2:		//判断卡片是否是黑名单卡 33表示卡是黑名单
			status  = Card_JudgeCsn();
			if(status == MI_OK)step++;
			else
			{
				Err_display(10);
				Loop = 0;
			}
			break;

		case 3:
			if(SavedataErr == 0)step++;
			else if(SavedataErr == 2)
			{
				Err_display(21);
				Loop = 0;
			}
			else
			{
				Err_display(20);
				Loop = 0;
			}
			break;

		case 4:
			SaveDirverNumber();
			IncSerId();
			step++;
			break;

		case 5:
			SaveDirverData();
			if(status == MI_OK)step++;
			else
			{
				Loop = 0;
			}
			break;


		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	return(step);
}


unsigned char CardReset(char *data,unsigned char *plen,unsigned char type)
{
	static int	receive_len[1] = {0};
	static char receive_buf[256]= {0};
	int result;
	unsigned char Loop,step;
	//  struct stat fdbuf;
	int i;


#if 0 // DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("CardReset() is called, type = %d, time = %ld\"%06ld.\n", type, now.tv_sec, now.tv_usec);
	}
#endif

	Loop = 1;
	step = 1;
	//  if((CardTwo == 0)||(type ==1))
	// {
	//     step = 1;
	// }
	// else
	// {
	//      step = 2;
	// }
	while(Loop)
	{
		switch(step)
		{
		case 1:

			for(i=0; i<5; i++)
			{
				result = ioctl(mf_fd, 0xAB);
				if(result == MI_OK)
				{
					step++;
					break;
				}
				usleep(1000);
			}
			if(i==5) Loop = 0;

			//result = ioctl(mf_fd, 0xAB);
			if(result == MI_OK)
			{
				step++;
			}
			else
			{
				Loop = 0;
			}
			break;

		case 2:
			CardTwo = 1;
			readcardnum =0;
			ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			read(mf_fd, receive_buf, receive_len[0]);

#if DBG_RC500
			{
				unsigned char i;
				printf("read RESET = %d\n",receive_len[0]);
				for(i =0 ; i < receive_len[0]; i ++)
				{
					printf("%02X ",receive_buf[i]);
				}
				printf("\n");
			}
#endif

			//ReadCardFirst: 0x55 - 优先M1卡,其他优先CPU卡
			if(((receive_buf[4]&0x20)&&(ReadCardFirst != 0x55))||(((receive_buf[4]&0x08)!=0x08)&&(receive_buf[4]&0x20)))
			{
				CardTypeIC = 0x20;
				ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				result = read(mf_fd, receive_buf, receive_len[0]);
				if(type == 0)
				{
					memset(&CardLan,0,sizeof(CardInform));
					memcpy(CardLan.UserIcNo,receive_buf,4);
					step++;
				}
				else
				{
					if(mystrncmp(CardLan.UserIcNo,receive_buf,4) == 0)
					{
						step++;
					}
					else
					{
						Loop = 0;
					}
				}

			}
			else if(receive_buf[4]&0x08)
			{
				ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				result = read(mf_fd, receive_buf, receive_len[0]);
				if(type == 0)
				{
					memset(&CardLan,0,sizeof(CardInform));
					memcpy(CardLan.UserIcNo,receive_buf,4);
					memcpy(data,receive_buf,receive_len[0]);
					*plen = receive_len[0];
					step = 0x08;
				}
				else
				{
					if(mystrncmp(CardLan.UserIcNo,receive_buf,4) == 0)
					{
						step = 0;
					}
					else
					{
						Loop = 0;
					}
				}
				CardTypeIC = 0x08;
				Loop = 0;
			}
			else
			{
				Loop = 0;
			}
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE, W_CPU);
			result = ioctl(mf_fd, TYPEA_CPU_REST);
			if(result == MI_OK)
			{
				if(type == 0)
				{
					step++;
				}
				else
				{
					step = 0;
					Loop = 0;
				}
				// step = 0x20;
				// Loop = 0;
			}
			else Loop = 0;
			break;


		case 4:
			ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			result = read(mf_fd, receive_buf, receive_len[0]);
			memcpy(data,receive_buf,receive_len[0]);
			*plen = receive_len[0];
			step = 0x20;
			Loop = 0;

#if DBG_RC500
			{
				unsigned char i;
				printf("TYPEA CPU RESET = %d\n",receive_len[0]);
				for(i =0 ; i < receive_len[0]; i ++)
				{
					printf("%02X ",receive_buf[i]);
				}
				printf("\n");
			}
#endif

			break;

		default :
			Loop = 0;
			break;
		}
	}

	readcardnum++;
	if((step!=0x08)&&(step!=0x20))
	{
		if(readcardnum > 100000)
		{
			close(mf_fd);
			mf_fd=open("/dev/typea",O_RDWR);
			if(mf_fd<0)
			{
				printf("Can't open /dev/typea \n");
				// close(mf_fd);
				return -2;
			}
			ioctl(mf_fd,DO_TYPEA_M1);
			readcardnum = 0;

#if  0 // DBG_RC500
			{
				struct timeval now;
				gettimeofday(&now,0);
				printf("\n\n %d DO_TYPEA_M1_0  time = %ld\"%06ld  \n\n",readcardnum,now.tv_sec, now.tv_usec);

			}
#endif
		}
		else if(readcardnum%1000==0)
		{
			ioctl(mf_fd,DO_TYPEA_M1);

#if 0
			{
				struct timeval now;
				gettimeofday(&now,0);
				printf("\n\n %d DO_TYPEA_M1_1  time = %ld\"%06ld  \n\n",readcardnum,now.tv_sec, now.tv_usec);

			}
#endif

		}
	}

	return step;
}

unsigned char CardReset_M1(char *data,unsigned char *plen,unsigned char type)
{
	static int	receive_len[1] = {0};
	static char receive_buf[256]= {0};
	int result;
	unsigned char Loop,step;
	//  struct stat fdbuf;
	int i;


#if 0 // DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("CardReset() is called, type = %d, time = %ld\"%06ld.\n", type, now.tv_sec, now.tv_usec);
	}
#endif

	Loop = 1;
	step = 1;

	while(Loop)
	{
		switch(step)
		{
		case 1:

			for(i=0; i<5; i++)
			{
				result = ioctl(mf_fd, 0xAB);
				if(result == MI_OK)
				{
					step++;
					break;
				}
				usleep(1000);
			}
			if(i==5) Loop = 0;

			//result = ioctl(mf_fd, 0xAB);
			if(result == MI_OK)
			{
				step++;
			}
			else
			{
				Loop = 0;
			}
			break;

		case 2:
			CardTwo = 1;
			readcardnum =0;
			ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			read(mf_fd, receive_buf, receive_len[0]);

#if DBG_RC500
			{
				unsigned char i;
				printf("read RESET = %d\n",receive_len[0]);
				for(i =0 ; i < receive_len[0]; i ++)
				{
					printf("%02X ",receive_buf[i]);
				}
				printf("\n");
			}
#endif
			if((receive_buf[4]&0x20) || (receive_buf[4]&0x08))
			{
			
			//ReadCardFirst: 0x55 - 优先M1卡,其他优先CPU卡
			if(((receive_buf[4]&0x20)&&(ReadCardFirst != 0x55))||(((receive_buf[4]&0x08)!=0x08)&&(receive_buf[4]&0x20)))
			{
				CardTypeIC = 0x20;
			}
			else if (receive_buf[4]&0x08)
			{
				CardTypeIC = 0x08;
			}


				step = receive_buf[4];
			
				ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				result = read(mf_fd, receive_buf, receive_len[0]);
				if(type == 0)
				{
					memset(&CardLan,0,sizeof(CardInform));
					memcpy(CardLan.UserIcNo,receive_buf,4);
					memcpy(data,receive_buf,receive_len[0]);
					*plen = receive_len[0];
				}
 				else if(mystrncmp(CardLan.UserIcNo,receive_buf,4) == 0)
				{
					step = 0;
				}
			}
			Loop = 0;

			break;

		default :
			Loop = 0;
			break;
		}
	}

	readcardnum++;
	if((step!=0x08)&&(step!=0x20))
	{
		if(readcardnum > 100000)
		{
			close(mf_fd);
			mf_fd=open("/dev/typea",O_RDWR);
			if(mf_fd<0)
			{
				printf("Can't open /dev/typea \n");
				// close(mf_fd);
				return -2;
			}
			ioctl(mf_fd,DO_TYPEA_M1);
			readcardnum = 0;

#if  0 // DBG_RC500
			{
				struct timeval now;
				gettimeofday(&now,0);
				printf("\n\n %d DO_TYPEA_M1_0  time = %ld\"%06ld  \n\n",readcardnum,now.tv_sec, now.tv_usec);

			}
#endif
		}
		else if(readcardnum%1000==0)
		{
			ioctl(mf_fd,DO_TYPEA_M1);

#if 0
			{
				struct timeval now;
				gettimeofday(&now,0);
				printf("\n\n %d DO_TYPEA_M1_1  time = %ld\"%06ld  \n\n",readcardnum,now.tv_sec, now.tv_usec);

			}
#endif

		}
	}

	return step;
}

// 玉溪公交: 从PBOC金融卡M1界面读取卡片类型
unsigned char GetPBOCCardType(unsigned char *cardType)
{
	unsigned char status;
	int flag,t;
	int  receive_len[1] = {0};
	unsigned char receive_buf[256]= {0};
	struct card_buf  test;
	unsigned char Keybuf[6] = {0x6A, 0x5A, 0x72, 0x11, 0x75, 0x78};

	DBG_PRINTF("GetPBOCCardType() is called.\n");

	*cardType = 0;

	flag = 1;
	t = 2;
	while(flag)
	{
		switch(t)
		{
		case 2:
			test.mode = KEYB;
			memcpy(test.key, Keybuf, sizeof(Keybuf));
			memset(test.rwbuf,0xff,16);
			t++;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE, W_CHAR);
			status = write(mf_fd, &test, sizeof(struct card_buf));
			if(status == MI_OK)t++;
			else flag = 0;
			break;

		case 4:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*YUXI_PBOC_USER_INFO_SECTOR + 3));
			if(status == MI_OK)t++;
			else flag = 0;
			break;
		case 5:
			// block0
			status = ioctl(mf_fd, RC531_READ, 4*YUXI_PBOC_USER_INFO_SECTOR + 0);
			if(status == MI_OK)
			{
				status = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				status = read(mf_fd, receive_buf, receive_len[0]);
				if(status == 0)
				{
					*cardType = receive_buf[13]; //用户卡类
					t++;
					DBG_PRINTF("GetPBOCCardType(): cardType = %d.\n", *cardType);
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;

		case 6:
			t = MI_OK;
			flag = 0;
			break;

		default:
			flag = 0;
			break;

		}
	}

	return status;
}

/****************************************************************************
* Function:	TypeAPiccSendAPDU
* Input:		Command to be sent
* Output:		Response data
****************************************************************************/
unsigned char TypeAPiccSendAPDU(uint8_t  *Send,uint8_t *Rcvdata,uint8_t Slen, uint8_t *Rlen)
{
	unsigned char status = 0xFF;
	int	receive_len[1] = {0};
	unsigned char receive_buf[256]= {0};

	DBG_RC500_PRINTF("TypeAPiccSendAPDU() is called.\n");

	*Rlen = 0;
	if (mf_fd != 0)
	{
		status = write(mf_fd, Send, Slen);
		DBG_RC500_PRINTF("TypeAPiccSendAPDU(): write status = %d.\n", status);
		if (status == MI_OK)
		{
			status = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			DBG_RC500_PRINTF("TypeAPiccSendAPDU(): read length status = %d, receive_len = %d.\n", status, receive_len[0]);
			if(receive_len[0] > 0)
			{
				memset(receive_buf, 0, sizeof(receive_buf));
				status = read(mf_fd, receive_buf, receive_len[0]);
				//DBG_PRINTF("TypeAPiccSendAPDU(): read status = %d, receive_len = %d.\n", status, receive_len[0]);
				memcpy(Rcvdata, receive_buf, receive_len[0]);
				*Rlen = receive_len[0];
			}
		}
	}

	return status;
}


/*
*************************************************************************************************************
- 函数名称 : void JudgeDate(void)
- 函数说明 : 判断卡片日期的合法性能
- 输入参数 : 无
- 输出参数 : 三种情况
*************************************************************************************************************
*/
unsigned char Card_JudgeDate(void)
{
	unsigned char status = 1;
	unsigned char i,t;
	unsigned char buff[7];
	LongUnon JackArm,Test,Buf;

	DBG_RC500_PRINTF("Card_JudgeDate() is called.\n");

	for(t = 0; t<5; t++)
	{
		memset(buff,0,sizeof(buff));
		Rd_time (buff);
		Time.year = buff[0];
		Time.month = buff[1];
		Time.day = buff[2];
		Time.hour = buff[3];
		Time.min = buff[4];
		Time.sec = buff[5];

		Buf.longbuf[0] = Time.day;
		Buf.longbuf[1] = Time.month;
		Buf.longbuf[2] = Time.year;
		Buf.longbuf[3] = 0x20;
		for(i = 0; i< 4 ; i++)Test.longbuf[i] = CardLan.EnableH[3 - i];
		for(i = 0; i< 4 ; i++)JackArm.longbuf[i] = CardLan.Effective[3 - i];
		if((Buf.i >= Test.i)&&(Buf.i <= JackArm.i)) status = 0;
		else if(Buf.i < Test.i)status = 1;
		else if(Buf.i > JackArm.i)status = 2;
		if(status == 0)break;
	}

	return status;
}





#if defined(CONFIG_BZLINUXBUS)

/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadCardInfor (void)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/

unsigned char ReadCardInfor (void)
{
	static int flag,t,ret;
	static int  receive_len[1] = {0};
	static char receive_buf[20]= {0};
	unsigned char Keybuf[8];
	//  unsigned char i;
#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("ReadCardInfor() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	flag = 1;
	t = 2;
	while(flag)
	{
		switch(t)
		{
		case 2:
			test.mode = KEYB;
			memset(test.key,0xFF,6);
			memset(test.rwbuf,0xff,16);
			memcpy(Keybuf,CardLan.UserIcNo,4);
			memcpy(Keybuf+4,SnBack,4);
			DES_CARD(KeyDes,Keybuf,test.key);
			t++;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE, W_CHAR);
			ret = write(mf_fd, &test, sizeof(struct card_buf));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 4:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.One + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 5:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.UserNum,receive_buf,2); //用户编号
					CardLan.MonthOrCountflag = receive_buf[8];
					memcpy(CardLan.SMonth,receive_buf+9,3);
					memcpy(CardLan.EMonth,receive_buf+12,3);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 6:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.CityId,  receive_buf,2);
					memcpy(CardLan.AppId,  receive_buf+2,2);
					memcpy(CardLan.CardCsnB,receive_buf+4,4);
					memcpy(CardLan.CardId,receive_buf+8,4);
					CardLan.CardType = receive_buf[12];
					CardLan.Pwdflag = receive_buf[14];
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;
		case 7:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.EnableH,  receive_buf+4,4);
					memcpy(CardLan.Effective,  receive_buf+8,4);
					memcpy(CardLan.UserWord,  receive_buf+12,3);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 8:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 9:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.Two);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 10:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 11:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 12:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 13:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.Thr);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 14:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 15:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 16:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 17:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.For);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SForZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 18:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.For + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SForOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 19:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.For + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SForTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 20:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 21:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.Fiv);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 22:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 23:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 24:
			t = MI_OK;
			flag = 0;
			break;

		default:
			flag = 0;
			break;

		}
	}

	return(t);
}


/************************************************************************
得到M1卡片信息
************************************************************************/
/*
unsigned char ReadCardInfor(void)
{
int flag,t;
int ret;
static int  receive_len[1] ={0};
static char receive_buf[20]={0};
unsigned char Keybuf[8];

	test.mode = KEYA;
	memset(test.key,0xFF,6);
	memset(test.rwbuf,0xff,16);
	memset(test.money,0x00,4);
        memset(&CardLan,0,sizeof(CardInform));
	flag = 1;
	t = 2;
	while(flag)
	{
		switch(t)
		{
		case 2:
			ret = ioctl(mf_fd, RC531_M1_CSN);
                        if(ret == MI_OK)t++;
                        else flag = 0;
			break;
		case 3:
			ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			if(ret == MI_OK)t++;
                        else flag = 0;
			break;
		case 4:
			ret = read(mf_fd, receive_buf, receive_len[0]);
			if(ret == MI_OK)t++;
                        else flag = 0;
			break;

		case 5:
                        memcpy(Keybuf,receive_buf,4);
                        memcpy(CardLan.UserIcNo,receive_buf,4);
			memcpy(Keybuf+4,SnBack,4);
                        DES_CARD(KeyDes,Keybuf,test.key);
			t++;
			break;

		case 6:
			ioctl(mf_fd, WRITE_TYPE, W_CHAR);
                        ret = write(mf_fd, &test, sizeof(struct card_buf));
			if(ret == MI_OK)t++;
                        else flag = 0;
			break;
		case 7:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.One + 3));//只读信息区域
                        if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 8:
                        ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One+ 1));
                        if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
			         memcpy(CardLan.CityId,receive_buf,2);	  //城市代码  HEX
				 CardLan.CardType =  receive_buf[12]; 		  //卡类信息       HEX
				 memcpy(CardLan.CardCsnB, receive_buf+4 , 4); //用户卡号 BCD
                                 memcpy(CardLan.CardId, receive_buf+8 , 4); //卡认证号
				 t++;
				}
				else
				{
					flag = 0;
				}
			}
                        else flag = 0;
                        break;
                case 9:
                        ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 2));
                        if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.EnableH,  receive_buf + 4,4);//启用日期 HEX
					memcpy(CardLan.Effective,receive_buf + 8,4);//有效日期 HEX
					memcpy(CardLan.UserWord,receive_buf + 12,3);//有效日期 HEX
					t++;
				}
				else
				{
					flag = 0;
				}
			}
                        else flag = 0;
                        break;

		case 10:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));	 //次数钱包区域
                        if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 11:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two + 1));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 12:
			ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			ret = read(mf_fd, receive_buf, receive_len[0]);
			if(ret >= 0)
			{
				 ret = MoneyYes(receive_buf);
				 if(ret == MI_OK)t++;
				 else flag = 0;

			}
			else flag = 0;
			break;
		case 13:
			memcpy(CardLan.Views,receive_buf,4);//次数钱包 HEX
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));//补贴钱包区域
                        if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 14:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr + 1));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 15:
			ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			ret = read(mf_fd, receive_buf, receive_len[0]);
			if(ret >= 0)
			{
				 ret = MoneyYes(receive_buf);
				 if(ret == MI_OK)t++;
				 else flag = 0;

			}
			else flag = 0;
			break;
		case 16:
			memcpy(CardLan.Subsidies,receive_buf,4);//补贴钱包 HEX
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));	 //现金钱包区域
                        if(ret == MI_OK)t++;
			else flag = 0;
			break;
		case 17:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.For + 1));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 18:
			ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			ret = read(mf_fd, receive_buf, receive_len[0]);
			if(ret >= 0)
			{
				 ret = MoneyYes(receive_buf);
				 if(ret == MI_OK)t++;
				 else flag = 0;

			}
			else flag = 0;
			break;

		case 19:
			memcpy(CardLan.QCash,receive_buf,4);//现金钱包 HEX
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));	 //可修改区域
                        if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 20:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv + 1));
                        if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
				memcpy(CardLan.OldTime, receive_buf, 6);         //上次交易时间   HEX
				CardLan.Period       = receive_buf[6];           //上次交易的时段 HEX
				CardLan.ViewsSection = receive_buf[7];           //当次消费次数 HEX
				CardLan.DaySection   = receive_buf[8];  	 //当日消费次数 HEX
				memcpy(CardLan.MonthSection, receive_buf + 9, 2);//当月消费次数 HEX
                                CardLan.EnterExitFlag = receive_buf[11];
				memcpy(CardLan.MoneyJack, receive_buf + 12,4);   //积分区域
				memcpy(Sector.SFivOne,receive_buf,16);
				t++;
				}
				else
				{
					flag = 0;
				}
			}
                        else flag = 0;
			break;
		case 21:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv + 2));
                        if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
				memcpy(CardLan.ViewsValue, receive_buf    , 4);//当次消费金额 HEX
				memcpy(CardLan.DayValue,   receive_buf + 4, 4);//当日消费金额 HEX
				memcpy(CardLan.MonthValue, receive_buf + 8, 4);//当月消费金额 HEX
				receive_buf[12]++;
				if(receive_buf[12] >= 3)receive_buf[12] = 0;
			        CardLan.WriteRecord = receive_buf[12];
				memcpy(CardLan.ViewMoney, receive_buf + 13,3);//累计交易次数 HEX
				memcpy(Sector.SFivTwo,receive_buf,16);
				t++;
				}
				else
				{
					flag = 0;
				}
			}
                        else flag = 0;
			break;

		default:
			flag = 0;
			break;
		}
	}

	if(t != 22)return t;
	return 0;
}

*/


/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckS5B0Light (unsigned char Pstatus)
- 函数说明 : S5B0正确性
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CheckS5B0Light(void)
{
	unsigned char i,XOR;
	unsigned char status = 1;

	XOR = Sector.SFivZero[0];
	for(i = 1; i <15; i++)
	{
		XOR ^= Sector.SFivZero[i];
	}
	if(XOR == Sector.SFivZero[15])							//校验位成功
	{
		if((Sector.SFivZero[0] >= 1)&&(Sector.SFivZero[0] <=3))
		{
			if(Sector.SFivZero[4] == ProEnd)
			{
				status = 0;
			}
		}
	}

	return(status);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckS5B1Light (unsigned char Pstatus)
- 函数说明 : S5B1正确性
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CheckS5B1Light(void)
{
	unsigned char i,XOR;
	unsigned char status = 1;

	XOR = Sector.SFivOne[0];
	for(i = 1; i <15; i++)
	{
		XOR ^= Sector.SFivOne[i];
	}
	if(XOR == Sector.SFivOne[15])							//校验位成功
	{
		if((Sector.SFivOne[0] >= 1)&&(Sector.SFivOne[0] <=3))
		{
			if(Sector.SFivOne[4] == ProEnd)	 //12.3修改 一定是要完成才能算正确
			{
				status = 0;
			}
		}
	}
	return(status);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckS5B0ORS5B1 (void)
- 函数说明 : S5B1 == S5B0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CheckS5B0ORS5B1(void)
{
	unsigned char i;
	unsigned char status = 1;
	for(i = 0; i < 16; i++)
	{
		if(Sector.SFivOne[i] != Sector.SFivZero[i]) break;
	}
	if(i == 16) status = 0;
	return(status);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeThirteen(void)
- 函数说明 : SxB2 -> SxB1
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeThirteen(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	int ret;

	CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
	}
	else if(CardLan.OldTransType == 0x30)
	{
		SectorNum = 4*LanSec.For;
	}
	else
	{
		return 1;
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum+ 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ret = ioctl(mf_fd,RC531_RESTORE,(SectorNum + 2));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd,RC531_TRANSFER,(SectorNum + 1));
			if(ret== MI_OK)step++;
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume 13 = %d\n",step);
#endif
	return(step);
}


/*已改正
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeSev (void)
- 函数说明 : 修复卡片-将SxB1的数据复制到SxB2中
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/

unsigned char ResumeTypeSev (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	static  char receive_buf[20]= {0};
	int ret;

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;
		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			if(ret == MI_OK)
			{
				memcpy(Sector.SForZero,Sector.STwoZero,16);
				memcpy(receive_buf,Sector.SForZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;
		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume12 = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeSix (void)
- 函数说明 : 修复卡片-将SxB1的数据复制到SxB2中
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeSix (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	unsigned char rbuf[16];
	int ret;

//   DBG_RC500_PRINTF("ResumeTypeSix() is called.\n");

	CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
		memcpy(Sector.STwoTwo,Sector.STwoOne,16);
		memcpy(rbuf,Sector.STwoOne,16);
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
		memcpy(Sector.SThrTwo,Sector.SThrOne,16);
		memcpy(rbuf,Sector.SThrOne,16);
	}
	else
	{
		SectorNum = 4*LanSec.For;
		memcpy(Sector.SForTwo,Sector.SForOne,16);
		memcpy(rbuf,Sector.SForOne,16);
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum+ 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(SectorNum+2));
			if(ret == MI_OK)
			{
				memcpy(receive_buf,rbuf,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

			////限次限额的，只取S2B0 不管S4B0
		case 3:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 4:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			if(ret == MI_OK)
			{
				memcpy(Sector.SForZero,Sector.STwoZero,16);
				memcpy(receive_buf,Sector.STwoZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume 10 11 = %d\n",step);
#endif
	return(step);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeFive (void)
- 函数说明 : 修复卡片-将S5B0的数据复制到S5B1中，将SxB1的数据复制到SxB2中
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeFive (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	unsigned char rbuf[16];
	int ret;

	DBG_RC500_PRINTF("ResumeTypeFive() is called.\n");

	CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
		memcpy(Sector.STwoTwo,Sector.STwoOne,16);
		memcpy(rbuf,Sector.STwoOne,16);
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
		memcpy(Sector.SThrTwo,Sector.SThrOne,16);
		memcpy(rbuf,Sector.SThrOne,16);
	}
	else
	{
		SectorNum = 4*LanSec.For;
		memcpy(Sector.SForTwo,Sector.SForOne,16);
		memcpy(rbuf,Sector.SForOne,16);
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv+1));
			if(ret == MI_OK)
			{
				memcpy(Sector.SFivOne,Sector.SFivZero,16);
				memcpy(receive_buf,Sector.SFivZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd, RC531_AUTHENT,SectorNum+3);
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 4:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(SectorNum+2));
			if(ret == MI_OK)
			{
				memcpy(receive_buf,rbuf,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

			/* //限次限额的，只取S2B0 不管S4B0
				   case 5:
					        ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			                if(ret == MI_OK)step++;
			                else Loop = 0;
					        break;

			       case 6:
			                ioctl(mf_fd, WRITE_TYPE,W_CARD);
			                ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			                if(ret == MI_OK)
					          {
			                        memcpy(Sector.SForZero,Sector.STwoZero,16);
			                        memcpy(receive_buf,Sector.SForZero,16);
						            ret = write(mf_fd, receive_buf, 16);
			                        if(ret == MI_OK)step++;
			                        else Loop = 0;
					          }
			                else Loop = 0;
			                break;
			*/
		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume89 = %d\n",step);
#endif
	return(step);
}
/*已改正
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeFour (void)
- 函数说明 : 修复卡片-将S5B1中的交易次数和指针加1，交易标志置为交易完成，
             改写S5B0，将S5B0的数据复制到S5B1中；将SxB1的数据复制到SxB2
             S2B0 --> S4B0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeFour (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Xor,i;
	unsigned char SectorNum;
	unsigned char rbuf[16];
	int ret;

	DBG_RC500_PRINTF("ResumeTypeFour() is called.\n");

	CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
		memcpy(Sector.STwoTwo,Sector.STwoOne,16);
		memcpy(rbuf,Sector.STwoOne,16);
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
		memcpy(Sector.SThrTwo,Sector.SThrOne,16);
		memcpy(rbuf,Sector.SThrOne,16);
	}
	else
	{
		SectorNum = 4*LanSec.For;
		memcpy(Sector.SForTwo,Sector.SForOne,16);
		memcpy(rbuf,Sector.SForOne,16);
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv));
			if(ret == MI_OK)
			{
				memcpy(Sector.SFivOne,Sector.SFivZero,16);
				Sector.SFivOne[4] = ProEnd;
				Xor = Sector.SFivOne[0];
				for(i = 1; i < 15 ; i ++)
				{
					Xor ^= Sector.SFivOne[i];
				}
				Sector.SFivOne[15] = Xor;

				memcpy(Sector.SFivZero,Sector.SFivOne,16);
				memcpy(receive_buf,Sector.SFivOne,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv+1));
			if(ret == MI_OK)
			{
				memcpy(receive_buf,Sector.SFivZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 4:
			ret = ioctl(mf_fd, RC531_AUTHENT,SectorNum+3);
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 5:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,SectorNum + 2);
			if(ret == MI_OK)
			{
				memcpy(receive_buf,rbuf,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

			/* ////限次限额的，只取S2B0 不管S4B0
				  case 6:
					        ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			                if(ret == MI_OK)step++;
			                else Loop = 0;
					         break;

			      case 7:
			                ioctl(mf_fd, WRITE_TYPE,W_CARD);
			                ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			                if(ret == MI_OK)
					          {
			                        memcpy(Sector.SForZero,Sector.STwoZero,16);
			                        memcpy(receive_buf,Sector.STwoZero,16);
						            ret = write(mf_fd, receive_buf, 16);
			                        if(ret == MI_OK)step++;
			                        else Loop = 0;
					          }
			                else Loop = 0;
			                break;
			*/
		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume7 = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeThree (void)
- 函数说明 : 修复卡片-将S5B0中的交易标志为交易完成，将S5B0的数据复制到S5B1中；将SxB1的数据复制到SxB2
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
/*
unsigned char ResumeTypeThree (void)
{
   unsigned char Loop = 1;
   unsigned char step = 1;
   unsigned char ret,Xor,i;
   static char receive_buf[20]={0};
   unsigned char SectorNum;
   CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
   if(CardLan.OldTransType == 0x10)
   	SectorNum = 4*LanSec.Two;
   else if(CardLan.OldTransType == 0x20)
   	SectorNum = 4*LanSec.Thr;
   else
        SectorNum = 4*LanSec.For;
   while(Loop)
   {
      switch(step)
      {

	   case 1:
		ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 2:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv));
                if(ret == MI_OK)
		{
			Sector.SFivZero[4] = ProEnd;
			Xor = Sector.SFivZero[0];
			for(i = 1; i < 15 ;i ++)
                        {
                             Xor ^= Sector.SFivZero[i];
                        }
                        Sector.SFivZero[15] = Xor;
      			memcpy(Sector.SFivOne,Sector.SFivZero,16);
                        memcpy(receive_buf,Sector.SFivZero,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv));
                break;
           case 3:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv+1));
                if(ret == MI_OK)
		{
                        memcpy(receive_buf,Sector.SFivZero,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv+1));
                break;
	   case 4:
		ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 5:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,(SectorNum+2));
                if(ret == MI_OK)
		{
      			memcpy(XFBuf2,XFBuf1,16);
                        memcpy(receive_buf,XFBuf1,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		// ret = ioctl(mf_fd, RC531_READ,(SectorNum+2));
                break;
           case 6:
                CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
   		if(CardLan.OldTransType == 0x10)
                {
   			memcpy(Sector.STwoOne,XFBuf1,16);
   			memcpy(Sector.STwoTwo,XFBuf1,16);
                }
   		else if(CardLan.OldTransType == 0x20)
                {
   			memcpy(Sector.SThrOne,XFBuf1,16);
   			memcpy(Sector.SThrTwo,XFBuf1,16);
                }
   		else
                {
   			memcpy(Sector.SForOne,XFBuf1,16);
   			memcpy(Sector.SForTwo,XFBuf1,16);
                }
                step++;
                break;
	   case 7:
		ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 8:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
                if(ret == MI_OK)
		{
                        memcpy(Sector.SForZero,Sector.STwoZero,16);
                        memcpy(receive_buf,Sector.SForZero,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,4*LanSec.For);
                break;
           default:
                Loop = 0;
                step = 0;
                break;
      }
   }
#if DBG_RC500
   printf("Resume6 = %d\n",step);
#endif
   return(step);
}
*/

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeFourNo (void)
- 函数说明 : 修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
/*
unsigned char ResumeTypeFourNo (void)
{
   unsigned char Loop = 1;
   unsigned char step = 1;
   unsigned char ret;
   static char receive_buf[20]={0};
   unsigned char SectorNum;
   CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
   if(CardLan.OldTransType == 0x10)
   	SectorNum = 4*LanSec.Two;
   else if(CardLan.OldTransType == 0x20)
   	SectorNum = 4*LanSec.Thr;
   else
        SectorNum = 4*LanSec.For;
   while(Loop)
   {

      switch(step)
      {
	  case 1:
		ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 2:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,(SectorNum+1));
                if(ret == MI_OK)
		{
      			memcpy(XFBuf1,XFBuf2,16);
                        memcpy(receive_buf,XFBuf1,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,(SectorNum+1));
                break;
	   case 3:
		ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 4:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv));
                if(ret == MI_OK)
		{
      			memcpy(Sector.SFivZero,Sector.SFivOne,16);
                        memcpy(receive_buf,Sector.SFivZero,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv));
                break;
           case 5:
                CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
   		if(CardLan.OldTransType == 0x10)
                {
   			memcpy(Sector.STwoOne,XFBuf1,16);
   			memcpy(Sector.STwoTwo,XFBuf1,16);
                }
   		else if(CardLan.OldTransType == 0x20)
                {
   			memcpy(Sector.SThrOne,XFBuf1,16);
   			memcpy(Sector.SThrTwo,XFBuf1,16);
                }
   		else
                {
   			memcpy(Sector.SForOne,XFBuf1,16);
   			memcpy(Sector.SForTwo,XFBuf1,16);
                }
                step++;
                break;
	   case 6:
		ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
                if(ret == MI_OK)step++;
                else Loop = 0;
		break;
           case 7:
                ioctl(mf_fd, WRITE_TYPE,W_CARD);
                ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.Two);
                if(ret == MI_OK)
		{
                        memcpy(Sector.STwoZero,Sector.SForZero,16);
                        memcpy(receive_buf,Sector.STwoZero,16);
			ret = write(mf_fd, receive_buf, 16);
                        if(ret == MI_OK)step++;
                        else Loop = 0;
		}
                else Loop = 0;
		//ret = ioctl(mf_fd, RC531_READ,4*LanSec.Two);
                break;
           default:
                Loop = 0;
                step = 0;
                break;
      }
   }
#if DBG_RC500
   printf("Resume5 = %d\n",step);
#endif
   return(step);
}
*/

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeTwo (void)
- 函数说明 :  // S4B0-->S2B0 , SxB2--> SxB1 ，S5B1-->S5B0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeTwo (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	unsigned char rbuf[16];
	int ret;

	DBG_RC500_PRINTF("ResumeTypeTwo() is called.\n");

	CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
		memcpy(Sector.STwoOne,Sector.STwoTwo,16);
		memcpy(rbuf,Sector.STwoTwo,16);
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
		memcpy(Sector.SThrOne,Sector.SThrTwo,16);
		memcpy(rbuf,Sector.SThrTwo,16);
	}
	else
	{
		SectorNum = 4*LanSec.For;
		memcpy(Sector.SForOne,Sector.SForTwo,16);
		memcpy(rbuf,Sector.SForTwo,16);
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2: //S4B0 -->S2B0
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.Two);
			if(ret == MI_OK)
			{
				memcpy(Sector.STwoZero,Sector.SForZero,16);
				memcpy(receive_buf,Sector.STwoZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 4:  //SXB2 -->SXB1
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(SectorNum+1));
			if(ret == MI_OK)
			{
				memcpy(receive_buf,rbuf,16);
				ret = write(mf_fd, receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 5:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 6:  //S5B1 -->S5B0
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv));
			if(ret == MI_OK)
			{
				memcpy(Sector.SFivZero,Sector.SFivOne,16);
				memcpy(receive_buf,Sector.SFivOne,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume 5 = %d\n",step);
#endif

	return(step);
}
/*OK
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeOne (void)
- 函数说明 : 修复卡片-将S5B1的数据复制到S5B0中
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeOne (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	int ret;

	DBG_RC500_PRINTF("ResumeTypeOne() is called.\n");

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two+ 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.Two);
			if(ret == MI_OK)
			{
				memcpy(Sector.STwoZero,Sector.SForZero,16);
				memcpy(receive_buf,Sector.SForZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 4:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
			if(ret == MI_OK)
			{
				memcpy(Sector.SFivZero,Sector.SFivOne,16);
				memcpy(receive_buf,Sector.SFivOne,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}
#if DBG_RC500
	printf("Resume 3 = %d\n",step);
#endif
	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeOneOther (void)
- 函数说明 : 修复卡片-将S5B1的数据复制到S5B0中
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeOneOther (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	int ret;

	DBG_RC500_PRINTF("ResumeTypeOneOther() is called.\n");

	while(Loop)
	{
		switch(step)
		{
			////限次限额的，只取S2B0 不管S4B0
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;
		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			if(ret == MI_OK)
			{
				memcpy(Sector.SForZero,Sector.STwoZero,16);
				memcpy(receive_buf,Sector.STwoZero,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;


		case 3:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 4:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv + 1));
			if(ret == MI_OK)
			{
				memcpy(Sector.SFivOne,Sector.SFivZero,16);
				memcpy(receive_buf,Sector.SFivOne,16);
				ret = write(mf_fd, receive_buf, 16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume34 = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeType (unsigned char Mode)
- 函数说明 : 修复卡片信息
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeType (unsigned char Mode)
{
	unsigned char status = 1;

	DBG_RC500_PRINTF("ResumeType() is called, mode = %d.\n", Mode);

	switch(Mode)
	{
	case 3:	//将S5B1的数据复制到S5B0中 S4B0 --> S2B0
		status = ResumeTypeOne();
		break;

	case 4://将S5B0的数据复制到S5B1中 S2B0 --> S4B0
		status = ResumeTypeOneOther();
		break;

	case 5:	// S4B0-->S2B0 , SxB2--> SxB1 ，S5B1-->S5B0
		status = ResumeTypeTwo();
		break;

		//case 6:	//将S5B0中的交易标志为交易完成，将S5B0的数据复制到S5B1中；将SxB1的数据复制到SxB2
		//       status = ResumeTypeThree();
		//       break;

	case 7:	//将S5B1中的交易次数和指针加1，交易标志置为交易完成，改写S5B0，
		//将S5B0的数据复制到S5B1中；将SxB1的数据复制到SxB2  S2B0 --> S4B0
		status = ResumeTypeFour();
		break;

	case 8:	//将S5B0的数据复制到S5B1中，将SxB1的数据复制到SxB2中 S2B0 --> S4B0
	case 9:
		status = ResumeTypeFive();
		break;

	case 10://将SxB1的数据复制到SxB2中 S2B0 --> S4B0
	case 11:
		status = ResumeTypeSix();
		break;

	case 12://将限次块复制到复制限次块中  S2B0 ->S4B0
		status = ResumeTypeSev();
		break;

	case 13://将SxB2的数据复制到SxB1中
		status = ResumeTypeThirteen();
		break;

	default :
		break;
		// case 40:
		//       status = ResumeTypeFourNo();
		//       break;
	}

	return(status);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckSXB1ORSXB2 (void)
- 函数说明 : SXB1 == SXB0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CheckSXB1ORSXB2(void)
{
	unsigned char i;
	unsigned char status = 1;
	for(i = 0; i < 16; i++)
	{
		if(XFBuf1[i] != XFBuf2[i]) break;
	}
	if(i == 16) status = 0;
	return(status);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckS2B0ORS4B0 (void)
- 函数说明 : S2B0 == S4B0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/

unsigned char CheckS2B0ORS4B0(void)
{
	unsigned char i;
	unsigned char status = 1;
	for(i = 0; i < 16; i++)
	{
		if(Sector.STwoZero[i] != Sector.SForZero[i]) break;
	}
	if(i == 16) status = 0;
	return(status);
}

/*OK
*************************************************************************************************************
- 函数名称 : unsigned char ProcessFunOne (HWND hDlg)
- 函数说明 : 过程1
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ProcessFunOne (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	DBG_RC500_PRINTF("ProcessFunOne() is called.\n");

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = CheckS5B1Light();				//S5B1
			if(status == MI_OK) step++;
			else
			{
				Err_display(2);
				Loop = 0;
			}
			break;

		case 2:
			CardLan.OldTransType = Sector.SFivOne[14]&0xf0;	//此处是用第一块来区分
			if(CardLan.OldTransType == 0x10) 			  //次数
			{
				memcpy(XFBuf1,Sector.STwoOne,16);
				memcpy(XFBuf2,Sector.STwoTwo,16);
			}
			else if(CardLan.OldTransType == 0x20) 			//补贴
			{
				memcpy(XFBuf1,Sector.SThrOne,16);
				memcpy(XFBuf2,Sector.SThrTwo,16);
			}
			else
			{
				memcpy(XFBuf1,Sector.SForOne,16);
				memcpy(XFBuf2,Sector.SForTwo,16);
			}
			step++;
			break;

		case 3:
			status = MoneyYes(XFBuf1);				//SXB1
			if(status == MI_OK) step++;
			else
			{
				status = MoneyYes(XFBuf2);			//SXB2
				if(status == MI_OK)
				{
					status = ResumeType(5);	//有可能在写扣钱的时候失败（第三步失败）需先修复限次块/钱包1块/过程0块
					if(status == MI_OK)step = 0;
					Loop = 0;
				}
				else
				{
					Err_display(3);
					Loop = 0;
				}
			}
			break;

		case 4:
			status = MoneyYes(XFBuf2);				// SXB2
			if(status == MI_OK) step++;
			else
			{
				Err_display(3);
				Loop = 0;
			}
			break;

		case 5:
			status = CheckSXB1ORSXB2();				//CK SXB1 = or !=  SXB2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(7); //扣费完成写过程标记失败
				if(status == MI_OK)
					step = 0;
				Loop = 0;
			}
			break;

		case 6:
			status = ResumeType(3); //
			if(status == MI_OK) step++;
			else  Loop = 0;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("ProcessFunOne = %d",step);
#endif
	return(step);
}
/*OK
*************************************************************************************************************
- 函数名称 : unsigned char ProcessFunTwo (HWND hDlg)
- 函数说明 : 过程2
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ProcessFunTwo (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	DBG_RC500_PRINTF("ProcessFunTwo() is called.\n");

	while(Loop)
	{
		switch (step)
		{

		case 1:
			CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
			if(CardLan.OldTransType == 0x10) 			//次数
			{
				memcpy(XFBuf1,Sector.STwoOne,16);
				memcpy(XFBuf2,Sector.STwoTwo,16);
			}
			else if(CardLan.OldTransType == 0x20) 			//补贴
			{
				memcpy(XFBuf1,Sector.SThrOne,16);
				memcpy(XFBuf2,Sector.SThrTwo,16);
			}
			else
			{
				memcpy(XFBuf1,Sector.SForOne,16);
				memcpy(XFBuf2,Sector.SForTwo,16);
			}
			step++;
			break;

		case 2:
			status = MoneyYes(XFBuf1);	//SXB1
			if(status == MI_OK) step++;
			else
			{
				Err_display(3);
				Loop = 0;
			}
			break;

		case 3:
			status = MoneyYes(XFBuf2);	//SXB2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(8); //S5B0 --> S5B1  SXB1 --> SXB2
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		case 4:
			status = CheckSXB1ORSXB2();		//SXB2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(8);//S5B0 --> S5B1  SXB1 --> SXB2
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;
		case 5:
			status = ResumeType(4);//S5B0 --> S5B1
			if(status == MI_OK) step++;
			else  Loop = 0;
			break;

		default:
			step = 0;
			Loop = 0;
			break;

		}
	}

#if DBG_RC500
	printf("ProcessFunTwo = %d",step);
#endif
	return(step);
}



/*OK
*************************************************************************************************************
- 函数名称 : unsigned char RepairCardInfor (void)
- 函数说明 : 修复卡片信息
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char RepairCardInfor (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("RepairCardInfor() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:							//有效日期是否可行
			status = Card_JudgeDate();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Err_display(1);
				Loop = 0;
			}
			break;

		case 2:
			status = CheckS5B0Light();				//S5B0 ?
			if(status == MI_OK) step++;
			else
			{
				status = ProcessFunOne();
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		case 3:
			status = CheckS5B1Light();				//S5B1 ?
			if(status == MI_OK) step++;
			else
			{
				status = ProcessFunTwo();
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;
		case 4:
			status = CheckS5B0ORS5B1();				//S5B0 =? S5B1
			if(status == MI_OK) step++;
			else
			{
				status = ProcessFunTwo();
				if(status == MI_OK)step = 0;
				Loop = 0;
			}
			break;

		case 5:
			CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
			if(CardLan.OldTransType == 0x10) 			//次数
			{
				memcpy(XFBuf1,Sector.STwoOne,16);
				memcpy(XFBuf2,Sector.STwoTwo,16);
			}
			else if(CardLan.OldTransType == 0x20) 			//补贴
			{
				memcpy(XFBuf1,Sector.SThrOne,16);
				memcpy(XFBuf2,Sector.SThrTwo,16);
			}
			else
			{
				memcpy(XFBuf1,Sector.SForOne,16);
				memcpy(XFBuf2,Sector.SForTwo,16);
			}
			step++;
			break;

		case 6:
			status = MoneyYes(XFBuf1);				//SXB1 ?
			if(status == MI_OK) step++;
			else
			{
				status = MoneyYes(XFBuf2);				//SXB2 ?
				if(status == MI_OK)
				{
					status = ResumeType(13); // SXB2 -> SXB1
					if(status == MI_OK) step = 0;
				}
				else
				{
					Err_display(4);
				}
				Loop = 0;
			}
			break;

		case 7:
			status = MoneyYes(XFBuf2);				//SXB2 ?
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(10); // SXB1 -> SXB2
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		case 8:
			status = CheckSXB1ORSXB2();				//SXB1 =? SXB2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(11); // SXB1 -> SXB2
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		case 9:
			status = CheckS2B0ORS4B0();				//S2B0 =? S4B0
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(12);//S2B0 -> S4B0
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}
	if(step == 0)
	{
		memcpy(CardLan.Views,Sector.STwoOne,4);
		memcpy(CardLan.Subsidies,Sector.SThrOne,4);
		memcpy(CardLan.QCash,Sector.SForOne,4);
		memcpy(CardLan.ViewsValue,Sector.STwoZero+4,3);
		memcpy(CardLan.DayValue,Sector.STwoZero+7,3);
		memcpy(CardLan.MonthValue,Sector.STwoZero+10,4);
		CardLan.Period = Sector.STwoZero[14];
		memcpy(CardLan.OldTime,Sector.SFivZero+8,6);

		CardLan.OldTransType = Sector.SFivOne[14] & 0xf0;
		CardLan.EnterExitFlag = Sector.SFivZero[3];			//进出标志
		CardLan.StationID = Sector.SFivTwo[0];
		CardLan.EnterCarCi = Sector.SFivTwo[1];
		CardLan.StationOn = Sector.SFivTwo[2];
		memcpy(CardLan.OldTermNo,Sector.SFivTwo+4,4);
	}

#if DBG_RC500
	printf("RepairCardInforstep = %d\n",step);
#endif

	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS5B0DatOne (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteS5B0DatOne (unsigned char mode)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Xor,i;
//    unsigned char timemoth,Smoth;
	ShortUnon Buf;
	int status;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("WriteS5B0DatOne() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Fiv + 1));
			if(status == MI_OK)
			{
				Sector.SFivOne[14] = ((Sector.FlagValue+1)<<4)| mode;
				//Sector.SFivOne[3] = CardLan.EnterExitFlag;
				Xor = Sector.SFivOne[0];
				for(i = 1; i < 15 ; i ++)
				{
					Xor ^= Sector.SFivOne[i];
				}
				Sector.SFivOne[15] = Xor;
				memcpy(receive_buf,Sector.SFivOne,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
			if(status == MI_OK)
			{
				Sector.SFivZero[4] = ProStart;
				Sector.SFivZero[0] ++;
				if(Sector.SFivZero[0] > 3) Sector.SFivZero[0] = 1;

				memset(Buf.intbuf,0,sizeof(ShortUnon));
				memcpy(Buf.intbuf,Sector.SFivZero+1,2);
				Buf.i++;
				memcpy(Sector.SFivZero+1,Buf.intbuf,2);

				memset(CardLan.ViewMoney,0,sizeof(CardLan.ViewMoney));
				memcpy(CardLan.ViewMoney,Sector.SFivZero+1,2);
				Sector.SFivZero[3] = CardLan.EnterExitFlag; //CardLan.StationOn
				// memcpy(Sector.SFivZero+5,DevNum.longbuf,3);
				memcpy(Sector.SFivZero+8,&Time,6);

				Sector.SFivZero[14] = ((Sector.FlagValue+1)<<4)|mode;

				Xor = Sector.SFivZero[0];
				for(i = 1; i < 15 ; i ++)
				{
					Xor ^= Sector.SFivZero[i];
				}
				Sector.SFivZero[15] = Xor;

				memcpy(receive_buf,Sector.SFivZero,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;
			/*
			case 4:
			   if((Section.Enable == 0x55)||(Section.StationOn == 0x55))
			   {
			       ioctl(mf_fd, WRITE_TYPE,W_CARD);
			       status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv+2);
			       if(status == MI_OK)
			       {
			           Sector.SFivTwo[0] = CardLan.StationID;
			           Sector.SFivTwo[1] = CardLan.EnterCarCi;
			           memcpy(Sector.SFivTwo+4,DevNum.longbuf,4);
			           memcpy(receive_buf,Sector.SFivTwo,16);
			           status = write(mf_fd, receive_buf, 16);
			           if(status == MI_OK)step++;
			           else Loop = 0;
			       }
			       else Loop = 0;
			   }
			   else
			   {
			       step++;
			   }
			   break;

			           case 5:
			               if(CardLan.TransCiFlag != 0)
			               {
			                   status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Sev + 3));
			                   if(status == MI_OK)step++;
			                   else Loop = 0;
			               }
			               else
			               {
			                   step = 100;
			               }
			               break;

			           case 6:
			               timemoth = BCD2HEX(Time.month);
			               if((timemoth>=1)&&(timemoth<=4)) Smoth = 0;
			               else if((timemoth>=5)&&(timemoth<=8)) Smoth = 1;
			               else if((timemoth>=9)&&(timemoth<=12)) Smoth = 2;
			               else return 1;
			               ioctl(mf_fd, WRITE_TYPE,W_CARD);
			               status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Sev+ Smoth));
			               if(status == MI_OK)
			               {
			                   memcpy(receive_buf,Sector.SSevnBuf,16);
			                   status = write(mf_fd, receive_buf, 16);
			                   if(status == MI_OK)step++;
			                   else Loop = 0;
			               }
			               else Loop = 0;
			               break;
			   */
		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("WriteS5B0DatOne = %d\n",step);
#endif

	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS2B0Dat (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteS2B0Dat(void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char XOR,i;
	int status;

	DBG_RC500_PRINTF("WriteS2B0Dat() is called.\n");


	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Two);
			if(status == MI_OK)
			{
				XOR = Sector.STwoZero[0];
				for(i = 1; i <15; i++)
				{
					XOR ^= Sector.STwoZero[i];
				}
				Sector.STwoZero[15] = XOR;  //计算校验位
				memcpy(Sector.SForZero,Sector.STwoZero,16);

				memcpy(receive_buf,Sector.STwoZero,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}
#if DBG_RC500
	printf("WriteS2B0Dat = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS4B0Dat (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/

unsigned char WriteS4B0Dat(void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	int status;

	DBG_RC500_PRINTF("WriteS4B0Dat() is called.\n");

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;
		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.For);
			if(status == MI_OK)
			{
				memcpy(receive_buf,Sector.SForZero,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("WriteS4B0Dat = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpMokey (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpMokey (unsigned char type)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SetorNum;
	int status;

#if DBG_RC500
	{	struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("TopUpMokey() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif


	if(Sector.FlagValue == 0)
	{
		SetorNum = 4*LanSec.Two;
		//  rbuf = (unsigned char *)(&Sector.STwoOne);
	}
	else if(Sector.FlagValue == 1)
	{
		SetorNum = 4*LanSec.Thr;
		//rbuf = (unsigned char *)(&Sector.SThrOne);
	}
	else
	{
		SetorNum = 4*LanSec.For;
		//  rbuf = (unsigned char *)(&Sector.SForOne);
	}

	memcpy(test.money,HostValue.longbuf,4);

	while(Loop)
	{
		switch (step)
		{
		case 1:
			ioctl(mf_fd, WRITE_TYPE,W_CHAR);
			status = write(mf_fd,&test,sizeof(struct card_buf));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			status = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			if(type == 0)
			{
				status = ioctl(mf_fd, RC531_DEC,(SetorNum + 1));
			}
			else
			{
				status = ioctl(mf_fd, RC531_INC,(SetorNum + 1));
			}
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

			/*
			        case 4:
			            status = ioctl(mf_fd, RC531_READ,(SetorNum + 1));
			            if(status == MI_OK)
			            {
			                status = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			                status = read(mf_fd, receive_buf, receive_len[0]);
			                if(status >= 0)
			                {
			                    memcpy(rbuf,receive_buf,16);
			                }
			            }
			            step++;
			            break;

			*/
		case 4:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpMokey = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteFlag (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteCiFlag (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char timemoth,Smoth;
	int status;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("WriteCiFlag() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Sev + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			timemoth = BCD2HEX(Time.month);
			if((timemoth>=1)&&(timemoth<=4)) Smoth = 0;
			else if((timemoth>=5)&&(timemoth<=8)) Smoth = 1;
			else if((timemoth>=9)&&(timemoth<=12)) Smoth = 2;
			else return 1;
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Sev+ Smoth));
			if(status == MI_OK)
			{
				memcpy(receive_buf,Sector.SSevnBuf,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("WriteCiFlag = %d\n",step);
#endif

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteFlag (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlag (unsigned char mode)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	// unsigned char Xor,i;
	unsigned char SECTOR;
	int  status;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("WriteFlag() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	SECTOR = Sector.SFivZero[0]-1;
	if(SECTOR > 2) SECTOR  = 0;


	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Six + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Six+SECTOR);
			if(status == MI_OK)
			{
				receive_buf[0] = Time.month;
				receive_buf[1] = Time.day;
				receive_buf[2] = Time.hour;
				receive_buf[3] = Time.min;

				if(Sector.FlagValue == 0)
				{
					memcpy(receive_buf+4,CardLan.Views,4);
				}
				else if(Sector.FlagValue == 1)
				{
					memcpy(receive_buf+4,CardLan.Subsidies,4);
				}
				else if(Sector.FlagValue == 2)
				{
					memcpy(receive_buf+4,CardLan.QCash,4);
				}
				else
				{
					memcpy(receive_buf+4,"\x00\x00\x00\x00",4);
				}
				memcpy(receive_buf+8,HostValue.longbuf,3);

				receive_buf[11] = ((Sector.FlagValue+1)<<4)|mode;
				memcpy(receive_buf+12,DevNum.longbuf,4);
				status = write(mf_fd, receive_buf,16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}
#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("WriteFlag(): time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif
	return(step);
}




/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS5B0DatTwo (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlagRstart(unsigned char type)
{
	static int receive_len[1]= {0};
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Qflag = 1;
	unsigned char Xor,i;
	unsigned char Timebuf[8];//Keybuf[8],
	unsigned char nbuf[20],len,ic=0;
	unsigned char SetorNum;
	LongUnon OldValue,Buf;
	int status = 1;

	if(Sector.FlagValue == 0)
	{
		SetorNum = 4*LanSec.Two;
		memcpy(Buf.longbuf,CardLan.Views,sizeof(LongUnon));
		if(type == 0)
		{
			OldValue.i = Buf.i - HostValue.i;
		}
		else
		{
			OldValue.i = Buf.i + HostValue.i;
		}
	}
	else if(Sector.FlagValue == 1)
	{
		SetorNum = 4*LanSec.Thr;
		memcpy(Buf.longbuf,CardLan.Subsidies,sizeof(LongUnon));
		if(type == 0)
		{
			OldValue.i = Buf.i - HostValue.i;
		}
		else
		{
			OldValue.i = Buf.i + HostValue.i;
		}
	}
	else
	{
		SetorNum = 4*LanSec.For;
		memcpy(Buf.longbuf,CardLan.QCash,sizeof(LongUnon));
		if(type == 0)
		{
			OldValue.i = Buf.i - HostValue.i;
		}
		else
		{
			OldValue.i = Buf.i + HostValue.i;
		}
	}

	SetColor(Mcolor);
	SetTextColor(Color_red);
	SetTextSize(32);
	TextOut(100 , 50, "温馨提示");
	TextOut(100 , 90, "刷卡错误");
	TextOut(85  , 130,"请重新刷卡");

	LEDL(1);
	beepopen(10);
	PlayMusic(15);

	while(Qflag)
	{
		Rd_time (Timebuf+1);
		if(Time.sec != Timebuf[6])
		{
			Timebuf[0] = 0x20;
			Time.year = Timebuf[1];
			Time.month = Timebuf[2];
			Time.day = Timebuf[3];
			Time.hour = Timebuf[4];
			Time.min = Timebuf[5];
			Time.sec = Timebuf[6];

			ic++;
			if(ic>30)
			{
				Qflag =0;
				break;
			}

			if((ic>2)&&(ic%3 == 0))
			{
				PlayMusic(15);
			}
		}

		Loop = 1;
		step = 1;

		while(Loop)
		{
			switch (step)
			{

			case 1:
				status = CardReset(nbuf, &len, 1);
				if(status == MI_OK)
				{
					step++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				test.mode = KEYB;
				// memset(test.key,0xFF,6);
				// memset(test.rwbuf,0xff,16);
				// memcpy(Keybuf,CardLan.UserIcNo,4);
				// memcpy(Keybuf+4,SnBack,4);
				// DES_CARD(KeyDes,Keybuf,test.key);
				step++;
				break;

			case 3:
				ioctl(mf_fd, WRITE_TYPE, W_CHAR);
				status = write(mf_fd, &test, sizeof(struct card_buf));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 4:
				status = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 5:
				status = ioctl(mf_fd, RC531_READ,(SetorNum+1));
				if(status == MI_OK)
				{
					status = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
					status = read(mf_fd, receive_buf, receive_len[0]);
					if(status >= 0)
					{
						memcpy(Buf.longbuf,receive_buf,4);
						step++;
					}
					else
					{
						Loop = 0;
					}
				}
				else Loop = 0;
				break;

			case 6:
				if(OldValue.i == Buf.i)
				{
					step++;
				}
				else
				{
					status = TopUpMokey(type);
					if(status == MI_OK)step++;
					else Loop = 0;

					/*
					    memcpy(test.money,HostValue.longbuf,4);
					    ioctl(mf_fd, WRITE_TYPE, W_CHAR);
					    status = write(mf_fd, &test, sizeof(struct card_buf));
					    if(type == 0)
					    {

					        status = ioctl(mf_fd, RC531_DEC,(SetorNum + 1));
					    }
					    else
					    {
					        status = ioctl(mf_fd, RC531_INC,(SetorNum + 1));
					    }
					    if(status == MI_OK)step++;
					    else Loop = 0;
					*/
				}
				break;



			case 7:
				status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 8:
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
				if(status == MI_OK)
				{
					Sector.SFivZero[4] = ProEnd;
					Xor = Sector.SFivZero[0];
					for(i = 1; i < 15 ; i ++)
					{
						Xor ^= Sector.SFivZero[i];
					}
					Sector.SFivZero[15] = Xor;
					memcpy(Sector.SFivOne,Sector.SFivZero,16);
					memcpy(receive_buf,Sector.SFivZero,16);
					status = write(mf_fd, receive_buf, 16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 9:
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv+1);
				if(status == MI_OK)
				{
					memcpy(receive_buf,Sector.SFivZero,16);
					status = write(mf_fd, receive_buf, 16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 10:
				// if((Section.Enable == 0x55)||(Section.StationOn == 0x55))
				// {
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv+2);
				if(status == MI_OK)
				{
					Sector.SFivTwo[0] = CardLan.StationID;
					Sector.SFivTwo[1] = CardLan.EnterCarCi;
					Sector.SFivTwo[2] = Section.Updown; //
					memcpy(Sector.SFivTwo+4,DevNum.longbuf,4);
					memcpy(receive_buf,Sector.SFivTwo,16);
					status = write(mf_fd, receive_buf, 16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				// }
				// else
				// {
				//     step++;
				// }
				break;

			default:
				Loop = 0;
				step = 0;
				break;
			}
		}

		if(step == 0)
		{
			Qflag = 0;
			break;
		}

	}
	LEDL(0);
	beepopen(11);

#if DBG_RC500
	printf("WriteFlagRstart = %d\n",step);
#endif

	return(step);
}





/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS5B0DatTwo (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteS5B0DatTwo (unsigned char type)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Xor,i;
	int status;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("WriteS5B0DatTwo() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
			if(status == MI_OK)
			{
				Sector.SFivZero[4] = ProEnd;
				Xor = Sector.SFivZero[0];
				for(i = 1; i < 15 ; i ++)
				{
					Xor ^= Sector.SFivZero[i];
				}
				Sector.SFivZero[15] = Xor;
				memcpy(Sector.SFivOne,Sector.SFivZero,16);
				memcpy(receive_buf,Sector.SFivZero,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv+1);
			if(status == MI_OK)
			{
				memcpy(receive_buf,Sector.SFivZero,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 4:
			// if((Section.Enable == 0x55)||(Section.StationOn == 0x55))
			// {
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv+2);
			if(status == MI_OK)
			{
				Sector.SFivTwo[0] = CardLan.StationID;
				Sector.SFivTwo[1] = CardLan.EnterCarCi;
				Sector.SFivTwo[2] = Section.Updown; //
				memcpy(Sector.SFivTwo+4,DevNum.longbuf,4);
				memcpy(receive_buf,Sector.SFivTwo,16);
				status = write(mf_fd, receive_buf, 16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			// }
			// else
			// {
			//     step++;
			// }
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

	if(step != 0)
	{
		step = WriteFlagRstart(type);
	}

#if DBG_RC500
	printf("WriteS5B0DatTwo = %d\n",step);
#endif
	return(step);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char CopySXB1ToSXB2 (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CopySXB1ToSXB2 (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SetorNum;
	int status;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("CopySXB1ToSXB2() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	if(Sector.FlagValue == 0)
	{
		SetorNum = 4*LanSec.Two;
	}
	else if(Sector.FlagValue == 1)
	{
		SetorNum = 4*LanSec.Thr;
	}
	else
	{
		SetorNum = 4*LanSec.For;
	}

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			status = ioctl(mf_fd,RC531_RESTORE,(SetorNum + 1));//只读信息区域
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			status = ioctl(mf_fd,RC531_TRANSFER,(SetorNum + 2));//只读信息区域
			if(status== MI_OK)step++;
			else Loop = 0;
			break;

		case 4:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("CopySXB1ToSXB2 = %d\n",step);
#endif
	return(step);

}
/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpCardInfor (HWND hDlg)
- 函数说明 : 充值金额
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpCardInfor (unsigned char type) // 0 为扣费  1为充值
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("TopUpCardInfor() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:
			if(type == 0)
			{
				status = WriteS5B0DatOne(0x03);		//写S5B0标志开始 3 消费
			}
			else
			{
				status = WriteS5B0DatOne(0x04); 	//写S5B0标志开始 4 补回
			}
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 2:
			if(CardLan.CiMoneyFlag == 0x01)
			{
				status = WriteS2B0Dat();			//写限次额信息
				if(status == MI_OK) step ++;
				else Loop = 0;
			}
			else
			{
				step ++;
			}
			break;

		case 3:
			if((CardLan.TransCiFlag != 0)&&(Sector.FlagValue == 0))
			{
				status = WriteCiFlag();
				if(status == MI_OK) step ++;
				else Loop = 0;
			}
			else
			{
				step ++;
			}
			break;

		case 4:
			status = TopUpMokey(type);			// 扣钱
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 5:
			status = WriteS5B0DatTwo(type);	//写S5B0完成，把S5B0复制到S5B1
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 6:
			status = CopySXB1ToSXB2();	//钱包 备份
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 7:
			if(CardLan.CiMoneyFlag == 0x01)
			{
				status = WriteS4B0Dat();		//限次限额 备份
				if(status == MI_OK) step ++;
				else Loop = 0;
			}
			else
			{
				step++;
			}
			break;

		case 8:
			if(type == 0)
			{
				status = WriteFlag(0x03);			//写卡交易记录
			}
			else
			{
				status = WriteFlag(0x04);			 //写卡交易记录4 补回
			}
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpCardInfor = %d\n",step);
#endif
	// transaction is regarded as successful if the electronic purse is changed.
	if(step >= 5) step = 0;
	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadSectorSix(void)
- 函数说明 : 上次交易记录
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
/*
unsigned char ReadSectorSix(void)
{
 int ret;
 unsigned char Loop = 1;
 unsigned char step = 1;
 static int  receive_len[1] ={0};
 static char receive_buf[20]={0};
    while(Loop)
    {
         switch (step)
	 {
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Six + 3));
                        if(ret == MI_OK)step++;
                        else Loop = 0;
			break;
		case 2:
                        if((CardLan.OldTransType == 0)||(CardLan.OldTransType > 3))
				CardLan.OldTransType = 1;
                        ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Six + CardLan.OldTransType - 1));
                        if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.OldTime,receive_buf,4);
					memcpy(CardLan.OldTermNo,receive_buf+12,3);
 					step++;
				}
				else
				{
					Loop = 0;
				}
			}
                        else Loop = 0;
                        break;
		case 3:
                        step = 0;
                        Loop = 0;
                	break;
	        default:
                        step = 0;
                        Loop = 0;
                	break;
	}
#if DBG_RC500
    printf("sixstep = %d\r\n",step);
#endif
    }
    return(step);
}
*/
/*
unsigned char TimeWriecarad(void)
{
    unsigned char Loop = 1;
    unsigned char step = 1;
    unsigned char status;

    while(Loop)
    {
        switch (step)
        {
        case 1:
            status = WriteS5B0DatOne();			//将标志置开始
            if(status == MI_OK) step ++;
            else Loop = 0;
            break;

        case 2:
            status = WriteS5B0DatTwo();			//将S5B0复制到S5B1
            if(status == MI_OK) step ++;
            else Loop = 0;
            break;

        case 3:
            status = WriteFlag();				//将标志置完成
            if(status == MI_OK) step ++;
            else Loop = 0;
            break;

        default:
            Loop = 0;
            step = 0;
            break;
        }
    }
#if DBG_RC500
    printf("TopUpCardInfor = %d\n",step);
#endif
    if(step >= 1) step = 0;
    return(step);
}
*/


unsigned char Timediff(void)
{
	unsigned char status = 1;
	LongUnon Timea,Timeb,Timec;

	Timea.i = Timeb.i = Timec.i = 0;

	Timea.longbuf[0] = Time.day;
	Timea.longbuf[1] = Time.month;
	Timea.longbuf[2] = Time.year;

	Timeb.longbuf[0] = CardLan.SMonth[2];
	Timeb.longbuf[1] = CardLan.SMonth[1];
	Timeb.longbuf[2] = CardLan.SMonth[0];

	Timec.longbuf[0] = CardLan.EMonth[2];
	Timec.longbuf[1] = CardLan.EMonth[1];
	Timec.longbuf[2] = CardLan.EMonth[0];

	if((Timea.i < Timec.i)&&(Timea.i >= Timeb.i))
	{
		status = 0;
	}
	return status;
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char YueConsume(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status = 1;


	while(Loop)
	{
		switch(step)
		{
		case 1:
			status = Timediff();
			if(status == MI_OK)
			{
				Sector.FlagValue = 8; // 时间包月
				step++;
			}
			else
			{
				Err_display(17);
				Loop = 0;
			}
			break;

		case 2:
			step++;  //写卡过程屏蔽，
			/*
			     status = TimeWriecarad();
			     if(status == MI_OK)
			      {
			          step++;
			      }
			     else
			       {
			        Loop = 0;
			       }
			*/
			break;

		case 3:
			IncSerId();
			step++;
			break;

		case 4:
			status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_PRESET); //保存数据  定额
			if(status == MI_OK) step++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("YueConsume = %d\n",step);
#endif

	return step;
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ReadcardSev(void)
{
	int flag,t,ret;
	static int  receive_len[1] = {0};
	static char receive_buf[20]= {0};
	unsigned char timemoth,Smoth;
	LongUnon uBuf,uValue;

	timemoth = BCD2HEX(Time.month);
	if((timemoth>=1)&&(timemoth<=4)) Smoth = 0;
	else if((timemoth>=5)&&(timemoth<=8)) Smoth = 1;
	else if((timemoth>=9)&&(timemoth<=12)) Smoth = 2;
	else return 1;

	flag =1;
	t =1;
	while(flag)
	{
		switch(t)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Sev+ 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 2:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Sev + Smoth));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SSevnBuf,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 3:
			memset(uValue.longbuf,0,4);
			uValue.longbuf[3] = 0xff;
			uValue.longbuf[0] = Time.year;
			if((timemoth == 1)||(timemoth == 5)||(timemoth == 9))
			{
				memcpy(uBuf.longbuf,Sector.SSevnBuf,4);
				memcpy(Sector.SSevnBuf,uValue.longbuf,4);

			}
			else if((timemoth == 2)||(timemoth == 6)||(timemoth == 10))
			{
				memcpy(uBuf.longbuf,Sector.SSevnBuf+4,4);
				memcpy(Sector.SSevnBuf+4,uValue.longbuf,4);
			}
			else if((timemoth == 3)||(timemoth == 7)||(timemoth == 11))
			{
				memcpy(uBuf.longbuf,Sector.SSevnBuf+8,4);
				memcpy(Sector.SSevnBuf+8,uValue.longbuf,4);
			}
			else if((timemoth == 4)||(timemoth == 8)||(timemoth == 12))
			{
				memcpy(uBuf.longbuf,Sector.SSevnBuf+12,4);
				memcpy(Sector.SSevnBuf+12,uValue.longbuf,4);
			}


			if(uBuf.longbuf[3] == 0xff)
			{
				uValue.longbuf[3] = 0xff;
				uValue.longbuf[0] = Time.year;
				if(uValue.i == uBuf.i) CardLan.TransCiFlag = 0;
				else {
					CardLan.TransCiFlag = 1;
					memset(CardLan.TimesTransfer,0,4);
				}
				t++;
			}
			else if(uBuf.i <= 65535)
			{
				memcpy(CardLan.TimesTransfer,uBuf.longbuf,4);
				CardLan.TransCiFlag = 1;
				t++;
			}
			else
			{
				flag = 0;
			}

			break;
		case 4:
			t = 0;
			flag = 0;
			break;

		default :
			flag = 0;
			break;
		}
	}


#if DBG_RC500
	printf("ReadcardSev = %d\n",t);
#endif


	return t;
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpCardInfor (HWND hDlg)
- 函数说明 : 充值金额
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpCardCi (unsigned char type) // 0 为扣费  1为充值
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("TopUpCardInfor() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch (step)
		{
		case 1:
			if(type == 0)
			{
				status = WriteS5B0DatOne(0x03);		//写S5B0标志开始
			}
			else
			{
				status = WriteS5B0DatOne(0x01); 	//写S5B0标志开始
			}
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 2:
			status = TopUpMokey(type);			// 扣钱
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 3:
			status = WriteS5B0DatTwo(type);	//写S5B0完成，把S5B0复制到S5B1
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:
			status = CopySXB1ToSXB2();	//钱包 备份
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 5:
			step = 0;
			Loop = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpCardCi = %d \n",step);
#endif
	// transaction is regarded as successful if the electronic purse is changed.
	if(step >= 3) step = 0;
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CiConsume(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status = 1;
	LongUnon bValue,aValue;


	while(Loop)
	{
		switch(step)
		{
		case 1:
			Sector.FlagValue = 0; // 选择次数钱包
			DecValue.i = HostValue.i=1;
			if(CardLan.OldTime[1] != Time.month) //
			{

				step++;
			}
			else
			{
				step = 3;
			}
			break;

		case 2:
			status = ReadcardSev();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Loop = 0;
			}
			break;

		case 3:
			status = YesOrNoCiShu();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Loop = 0;
			}
			break;

		case 4:
			memcpy(aValue.longbuf,CardLan.Views,4);
			memcpy(bValue.longbuf,CardLan.TimesTransfer,4);
			if(CardLan.TransCiFlag != 0)
			{
				if(bValue.i != 0)
				{
					if(aValue.i > bValue.i) {

						HostValue.i = aValue.i - bValue.i -1;
						DecValue.i = HostValue.i ;
						status = TopUpCardInfor(0);
						if(status == MI_OK)
						{
							memcpy(CardLan.Views,bValue.longbuf,4);
							DecValue.i = HostValue.i =1 ;
							step++;
						}
						else Loop = 0;

					}
					else
					{
						HostValue.i = bValue.i - aValue.i -1 ;
						DecValue.i = HostValue.i ;
						status = TopUpCardInfor(1);
						if(status == MI_OK)
						{
							memcpy(CardLan.Views,bValue.longbuf,4);
							DecValue.i = HostValue.i =1 ;
							step++;
						}
						else Loop = 0;
					}
				}
				else if((aValue.i != 0)&&(bValue.i == 0))
				{
					DecValue.i = HostValue.i = aValue.i;
					status = TopUpCardCi(0);
					if(status == MI_OK)
					{
						IncSerId();
						Sector.FlagValue = 10; // 时间包月
						status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_PRESET); //保存数据  定额
					}
					Loop = 0;
				}
				else
				{
					Loop = 0;
				}
			}
			else
			{
				if(aValue.i > 0)
				{
					DecValue.i = HostValue.i=1;
					status = TopUpCardInfor(0);
					if(status == MI_OK)
					{
						step++;
					}
					else Loop = 0;
				}
				else
				{
					Loop = 0;
				}

			}
			break;


		case 5:
			IncSerId();
			step++;
			break;

		case 6:
			Sector.FlagValue = 9; // 时间包月
			status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_PRESET); //保存数据  定额
			if(status == MI_OK) step++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		case 7:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("CiConsume = %d\n",step);
#endif

	return step;
}



/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ReadorRepairCard (void)
{
	unsigned char Loop = 1;
	unsigned char step = 2;
	unsigned char status;
	unsigned char FlagM = 0;

	DBG_RC500_PRINTF("ReadorRepairCard() is called.\n");

	BFlaglessfive = 0;
	while(Loop)
	{
		switch (step)
		{
		case 1:								//读卡
			// status = ReadCardInfor();
			// if(status == MI_OK) step ++;
			// else
			// {
			//     Loop = 0;
			//  }
			step ++;
			break;

		case 2:
			status = RepairCardInfor();				//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(0);				//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:
			HostValue.i = DecValue.i = 0;
			if(CardLan.MonthOrCountflag != 0)
			{
				if(CardLan.MonthOrCountflag == 1)
				{
					status = YueConsume();
					if(status == MI_OK) step = 0;
					else Loop = 0;
				}
				else if(CardLan.MonthOrCountflag == 2)
				{
					status = CiConsume();
					if(status == MI_OK) step = 0;
					else step +=2;
				}
				else step ++;

			}
			else
			{
				step ++;
			}
			break;

		case 5:	//扣次
			memcpy(JackArm.longbuf,CardLan.Views,4);
			if(JackArm.i > 0)
			{
				HostValue.i = DecValue.i = 1;
				Sector.FlagValue = 0;
				FlagM = YesOrNoCiShu();
				if(FlagM != 0)step++;
				else
				{
					step = 9;
				}
			}
			else step++;
			break;

		case 6:
			status = AnalysisSheet(1);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 7:								//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if((Test.i >= HostValue.i)&&(Test.i !=0 ))
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 8:								//扣现金
			status = YesOrNoMoney();
			if(status == MI_OK) step ++;
			else if(status == 0x01)					//超过时段消费金额
			{
				Err_display(13);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else if(status == 0x02)					//超过今天消费金额
			{
				Err_display(14);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else							//超过当月消费金额
			{
				Err_display(15);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 9:
			status = TopUpCardInfor(0);
			if(status == MI_OK)
			{
				step++;
				IncSerId();
			}
			else Loop = 0;
			break;

		case 10:
			status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_PRESET); //保存数据  定额
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}
	ioctl(mf_fd, RC531_HALT);


#if DBG_RC500
	printf("ReadorRepairCard = %d\n",step);
#endif

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char FreeReadorRepairCard(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status = 1;

	DBG_RC500_PRINTF("FreeReadorRepairCard() is called.\n");

	BFlaglessfive = 0;
	while(Loop)
	{
		switch (step)
		{
		case 1:								//读卡
			status = ReadCardInfor();
			if(status == MI_OK) step ++;
			else
			{
				Loop = 0;
			}
			break;

		case 2:
			status = RepairCardInfor();				//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(0);				//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:
			status = AnalysisSheet(0);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 5:								//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if((Test.i >= HostValue.i)&&(Test.i !=0 ))
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 6:								//扣现金
			status = YesOrNoMoney();
			if(status == MI_OK) step ++;
			else if(status == 0x01)					//超过时段消费金额
			{
				Err_display(13);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else if(status == 0x02)					//超过今天消费金额
			{
				Err_display(14);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else							//超过当月消费金额
			{
				Err_display(15);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 7:
			status = TopUpCardInfor(0);
			if(status == MI_OK)
			{
				step++;
				IncSerId();
			}
			else Loop = 0;
			break;

		case 8:
			status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_FLEXIBLE); //保存数据 自由
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("FreeReadorRepairCard = %d\n",step);
#endif
	return(step);
}



unsigned char ExitCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	ShortUnon Bufs;

	DBG_RC500_PRINTF("ExitCarProgram() is called.\n");

	while(Loop)
	{
		switch(step)
		{
		case 1:
			status = SectionSheet();
			if(status == MI_OK) step++;
			else if(status == 1)
			{
				Err_display(16);
				Loop = 0;
			}
			else
			{
				Err_display(50);  //没有上车
				Loop = 0;
			}
			break;

		case 2:
			//  status = AnalysisSheet(0);				//查消费表
			// if(status == MI_OK) step ++;
			//else
			//{
			//    Err_display(16);
			//    Loop = 0;
			//}
			HostValue.i = SectionDiscountRate(HostValue.i,CardLan.CardType);
			step ++;
			break;

		case 3:
			if(Section.Updoor == 0x02)
			{
				if((CardLan.EnterCarCi == 0)||(CardLan.EnterCarCi >= 100)) CardLan.EnterCarCi = 1;

				HostValue.i = (unsigned int)( HostValue.i * CardLan.EnterCarCi);
				DecValue.i = HostValue.i;

				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段
				}

				// memcpy(Buf.longbuf,Section.DeductMoney,4); //

			}
			else
			{
				CardLan.EnterCarCi = 1;
				DecValue.i = HostValue.i;
				//memcpy(Buf.longbuf,Section.DeductMoney,4); //

				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段

				}
			}

			Buf.i = SectionDiscountRate(Buf.i,CardLan.CardType);

			Buf.i = (unsigned int)(Buf.i * CardLan.EnterCarCi);

			if(Buf.i >= HostValue.i)									//AA增值
			{
				HostValue.i = Buf.i - HostValue.i;
				CardLan.StationDEC = 0xAA;
			}
			else														//55减值
			{
				HostValue.i = HostValue.i - Buf.i;
				CardLan.StationDEC = 0x55;
			}
			memset(Bufs.intbuf,0,sizeof(ShortUnon));
			memcpy(Bufs.intbuf,Sector.SFivZero+1,2);
			Bufs.i--;
			memcpy(Sector.SFivZero+1,Bufs.intbuf,2);

			CardLan.StationID= 0;
			CardLan.EnterCarCi = 0;
			CardLan.EnterExitFlag = 0;
			step++;
			break;

		default :
			step =0;
			Loop =0;
			break;
		}
	}

#if  DBG_RC500
	printf("ExitCarProgram = %d\n",step);
#endif


	return step;
}




unsigned char EnterCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	ShortUnon Bufs;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("EnterCarProgram() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch(step)
		{
		case 1:
			if(Section.Updown)
			{
				memcpy(HostValue.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
			}
			else
			{
				memcpy(HostValue.longbuf,Section.DeductMoney,4);	//预扣金额 分段
			}
			HostValue.i = SectionDiscountRate(HostValue.i,CardLan.CardType);
			step++;
			break;

		case 2:
			memset(Buf.longbuf,0,4);
			memcpy(Buf.longbuf,CardLan.OldTermNo,4);
			if((Buf.i == DevNum.i)&&(Section.SationNow == CardLan.StationID)&&(CardLan.EnterExitFlag == 0x55)&&(Section.Updoor == 0x01)&&(Section.Updown == CardLan.StationOn))
			{
				status = OverTimeEnter();
				if(status != 0)
				{
					if(CardLan.EnterCarCi >= 100)CardLan.EnterCarCi = 0;
					CardLan.EnterCarCi ++;
					CardLan.EnterExitFlag = 0x55;

					memset(Bufs.intbuf,0,sizeof(ShortUnon));
					memcpy(Bufs.intbuf,Sector.SFivZero+1,2);
					Bufs.i--;
					memcpy(Sector.SFivZero+1,Bufs.intbuf,2);


				}
				else
				{
					CardLan.EnterCarCi = 1;
					CardLan.EnterExitFlag = 0x55;
				}
			}
			else
			{
				CardLan.EnterCarCi = 1;
				CardLan.EnterExitFlag = 0x55;
				CardLan.StationID = Section.SationNow;
			}
			step++;
			break;

		default :
			step = 0;
			Loop = 0;
			break;
		}
	}

	return step;
}

//SectionSheet
unsigned char SectionFares(void)
{
	unsigned char Loop = 1;
	unsigned char step = 2;
	unsigned char status = 1;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("SectionFares() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif


	CardLan.StationDEC  = 0x55;

	while(Loop)
	{
		switch (step)
		{
		case 1: 							//读卡
			// status = ReadCardInfor();
			// if(status == MI_OK) step ++;
			//  else
			// {
			//     Loop = 0;
			// }
			break;

		case 2:
			status = RepairCardInfor(); 			//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(2); 			//权限
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 4:
			HostValue.i = DecValue.i = 0;
			switch(Section.Updoor)
			{
			case 1:
				status = EnterCarProgram();
				if(status == MI_OK)
				{
					step ++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				if(CardLan.EnterExitFlag == 0x55) 							  //出车
				{
					if(OverTimeEnter() != 0)								  //标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||((Section.SationNow == 1)&&(CardLan.StationID!=0)))
						{
							status = ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							Err_display(50);  //没有上车
							Loop = 0;
						}
					}
					else
					{
						Err_display(50);  //没有上车
						Loop = 0;

					}
				}
				else
				{
					if(memcmp(DevNum.longbuf,CardLan.OldTermNo,4) == 0)
					{
						Err_display(51);  //已经下车
					}
					else
					{
						Err_display(50);  //没有上车
					}
					Loop = 0;
				}
				break;

			default:
				if(CardLan.EnterExitFlag == 0x55)								//出车
				{
					if(OverTimeEnter() != 0)									//标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||((Section.SationNow == 1)&&(CardLan.StationID!=0)))
						{
							status =  ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							status = EnterCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
					}
					else
					{
						status = EnterCarProgram();
						if(status == MI_OK)
						{
							step ++;
						}
						else
						{
							Loop = 0;
						}

					}
				}
				else
				{
					status = EnterCarProgram();
					if(status == MI_OK)
					{
						step ++;
					}
					else
					{
						Loop = 0;
					}
				}
				break;
			}
			break;


		case 5: 							//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if(CardLan.StationDEC == 0x55)
			{
				if((Test.i >= HostValue.i)&&(Test.i !=0 ))
				{
					Sector.FlagValue = 1;
					step++;
				}
				else if(Buf.i >= HostValue.i)
				{
					if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
					Sector.FlagValue = 2;
					step++;
				}
				else
				{
					Err_display(12);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}

			}
			else
			{
				if(CardLan.OldTransType == 0x10)
				{
					Sector.FlagValue = 0;
				}
				else if(CardLan.OldTransType == 0x20)
				{
					Sector.FlagValue = 1;
				}
				else
				{
					Sector.FlagValue = 2;
				}
				step++;
			}
			break;

		case 6: 							//扣现金
			if(CardLan.StationDEC == 0x55)
			{
				status = YesOrNoMoney();
				if(status == MI_OK) step ++;
				else if(status == 0x01) 				//超过时段消费金额
				{
					Err_display(13);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
				else if(status == 0x02) 				//超过今天消费金额
				{
					Err_display(14);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
				else							//超过当月消费金额
				{
					Err_display(15);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
			}
			else
			{
				step++;
			}
			break;

		case 7:
			if(CardLan.StationDEC ==0x55)
			{
				status = TopUpCardInfor(0);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			else
			{
				status = TopUpCardInfor(1);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			break;

		case 8:
			status = SaveCardData(CARD_SPEC_M1_LINUX, CONSUME_MODE_SECTIONAL); //保存数据 分段
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("SectionFares = %d\n",step);
#endif
	return(step);
}









#elif  defined(CONFIG_LINUXBUS8BIT)

/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadOperCard (void)
- 函数说明 : 读卡
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ReadCardInfor(void)
{
	int ret;
	static int  receive_len[1] = {0};
	static char receive_buf[20]= {0};
	unsigned char Keybuf[8];
	unsigned char flag,t;

	flag = 1;
	t = 2;
	while(flag)
	{
		switch(t)
		{
		case 2:
			test.mode = KEYB;
			memset(test.key,0xFF,6);
			memset(test.rwbuf,0xff,16);
			memcpy(Keybuf,CardLan.UserIcNo,4);
			memcpy(Keybuf+4,SnBack,4);
			DES_CARD(KeyDes,Keybuf,test.key);
			t++;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE, W_CHAR);		//写内部BUF－－－－＞下密钥
			ret = write(mf_fd, &test, sizeof(struct card_buf));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 4:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.One + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 5:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.One);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SOneZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 6:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SOneOne,receive_buf,16);
					memcpy(CardLan.UserWord,receive_buf+5,3);  // 用户卡密码
					memcpy(CardLan.CardCsnB+1,receive_buf+8,3); // 卡号
					memcpy(CardLan.EnableH+1,receive_buf+2,3); // 启用日期
					memcpy(CardLan.Effective+1,receive_buf+12,3); // 有效日期
					CardLan.EnableH[0] = 0x20;
					CardLan.Effective[0] = 0x20;
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 7:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SOneTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 8:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 9:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.Two);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoZero,receive_buf,16); //
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 10:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoOne,receive_buf,16); //
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 11:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 12:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrOne,receive_buf,16); //
					CardLan.CardType = receive_buf[0];    //卡类
					CardLan.CardGroup = receive_buf[1];   //卡组
					memcpy(CardLan.UserNum,receive_buf+2,2); //用户编号
					memcpy(CardLan.OldTime,receive_buf+4,3); //上次交易时间
					memcpy(CardLan.OldTime+3,receive_buf+8,3); //上次交易时间
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 13:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrTwo,receive_buf,16); //
					memcpy(CardLan.ViewMoney,receive_buf+6,2); //用户编号
					CardLan.StationOn = receive_buf[5];   //卡组
					CardLan.EnterExitFlag = receive_buf[8];    //卡类
					CardLan.StationID = receive_buf[9];   //卡组
					CardLan.EnterCarCi = receive_buf[10];   //卡组
					memcpy(CardLan.OldTermNo,receive_buf+11,4); //用户编号
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 14:
			t = 0;
			flag = 0;
			break;

		default:
			flag = 0;
			break;
		}
	}

	return t;

}


unsigned char CopySXB1ToSXB2(unsigned char type)
{
	static char receive_buf[20]= {0};
	unsigned char Loop =1;
	unsigned char step =1;
	unsigned char *rbuf;
	unsigned char status = 1;
	unsigned char SetorNum;

	if(type)
	{
		SetorNum = LanSec.Two*4;
		rbuf = (unsigned char *)&Sector.STwoOne;
	}
	else
	{
		SetorNum = LanSec.One*4;
		rbuf = (unsigned char *)&Sector.SOneTwo;
	}

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			status = ioctl(mf_fd, RC531_WRITE,SetorNum);
			if(status == MI_OK)
			{
				memcpy(receive_buf,rbuf,16);
				status = write(mf_fd, receive_buf,16);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			break;

		case 3:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("CopySXB1ToSXB2 = %d\n",step);
#endif

	return step;
}




unsigned char RepairCardInfor (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;
	unsigned char rbuf[16];

	while(Loop)
	{
		switch(step)
		{
		case 1:
			status = Card_JudgeDate();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Err_display(1);
				Loop = 0;
			}
			break;

		case 2:
			if(CardLan.CardType != 0)
			{
				step++;
			}
			else
			{
				Err_display(2);
				Loop = 0;
			}
			break;

		case 3:
			memcpy(rbuf,Sector.STwoZero,16);
			status = MoneyYes(rbuf);
			if(status == MI_OK)
			{
				memcpy(CardLan.QCash,Sector.STwoZero,4); //现金金钱
				step++;
			}
			else
			{
				memcpy(rbuf,Sector.STwoOne,16);
				status = MoneyYes(rbuf);
				if(status == MI_OK)
				{
					status = CopySXB1ToSXB2(1);
					if(status == MI_OK)
					{
						memcpy(CardLan.QCash,Sector.STwoOne,4); //现金金钱
						step++;
					}
					else
					{
						Loop = 0;
					}
				}
				else
				{
					Err_display(3);
					Loop = 0;
				}
			}
			break;

		case 4:
			memcpy(rbuf,Sector.SOneZero,16);
			status = MoneyYes(rbuf);
			if(status == MI_OK)
			{
				memcpy(CardLan.Subsidies,Sector.SOneZero,4); //补贴金钱
			}
			else
			{
				memcpy(rbuf,Sector.SOneOne,16);
				status = MoneyYes(rbuf);
				if(status == MI_OK)
				{
					status = CopySXB1ToSXB2(0);
					if(status == MI_OK)
					{
						memcpy(CardLan.Subsidies,Sector.SOneTwo,4); //补贴金钱
					}
				}
			}
			step++;
			break;

		case 5:
			step = 0;
			Loop = 0;
			break;

		default :
			Loop = 0;
			break;

		}
	}


#if DBG_RC500
	printf("RepairCardInfor = %d\n",step);
#endif
	return step;
}





/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpMokey (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpMokey (unsigned char type)
{
//static int  receive_len[1] ={0};
//static char receive_buf[20]={0};
	int ret;
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SetorNum,Sectorbuf;



	if(Sector.FlagValue == 1)
	{
		SetorNum = 4*LanSec.One;
		Sectorbuf= SetorNum +2;
	}
	else
	{
		SetorNum = 4*LanSec.Two;
		Sectorbuf= SetorNum +1;
	}
	memcpy(test.money,HostValue.longbuf,4);

	while(Loop)
	{
		switch (step)
		{
		case 1:
			ioctl(mf_fd, WRITE_TYPE,W_CHAR);
			ret = write(mf_fd,&test,sizeof(struct card_buf));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			if(type == 0)
			{
				ret = ioctl(mf_fd, RC531_DEC,SetorNum);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else {
				ret = ioctl(mf_fd, RC531_INC,SetorNum);
				if(ret == MI_OK)step++;
				else Loop = 0;

			}
			break; //RC531_TRANSFER

		case 4:
			ret = ioctl(mf_fd, RC531_RESTORE,SetorNum);
			if(ret == MI_OK)step++;
			else Loop = 0;
			break; //RC531_TRANSFER

		case 5:
			ret = ioctl(mf_fd, RC531_TRANSFER,Sectorbuf);
			if(ret == MI_OK)step++;
			else Loop = 0;
			break; //RC531_TRANSFER

			/*
			    			ret = ioctl(mf_fd, RC531_READ,Sectorbuf);
			    			if(ret == MI_OK)
			    			{
			        			ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
			        			ret = read(mf_fd, receive_buf, receive_len[0]);
			        			if(ret >= 0)
			        			{
			                         step++;
			        			}
			        			else Loop = 0;
			    			}
			    			else  Loop = 0;
			    			break;

			        case 5:
			                 ioctl(mf_fd, WRITE_TYPE,W_CARD);
			                 ret = ioctl(mf_fd, RC531_WRITE,Sectorbuf);
			                 if(ret == MI_OK)
			    		      {
			        			  ret = write(mf_fd, receive_buf,16);
			        	          if(ret == MI_OK)step++;
			        	            else Loop = 0;
			    		      }
			    	   	    break;
			*/
		case 6:
			step = 0;
			Loop = 0;
			break;

		default:
			Loop = 0;

			break;
		}
	}

#if DBG_RC500
	printf("TopUpMokey = %d\n",step);
#endif
	if(step > 3) step = 0;

	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS5B0DatTwo (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlagRstart(void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Qflag = 1;
	unsigned char Xor,i;
	unsigned char Keybuf[8],Timebuf[8];
	unsigned char nbuf[20],len,ic=0;
	int status = 1;
	ShortUnon Bufs;



	SetColor(Mcolor);
	SetTextColor(Color_red);
	SetTextSize(32);
	TextOut(100 , 50, "温馨提示");
	TextOut(100 , 90, "刷卡错误");
	TextOut(85  , 130,"请重新刷卡");

	LEDL(1);
	beepopen(10);
	PlayMusic(15);

	while(Qflag)
	{
		Rd_time (Timebuf+1);
		if(Time.sec != Timebuf[6])
		{
			Timebuf[0] = 0x20;
			Time.year = Timebuf[1];
			Time.month = Timebuf[2];
			Time.day = Timebuf[3];
			Time.hour = Timebuf[4];
			Time.min = Timebuf[5];
			Time.sec = Timebuf[6];

			ic++;
			if(ic>30)
			{
				Qflag =0;
				break;
			}

			if((ic>2)&&(ic%3 == 0))
			{
				PlayMusic(15);
			}
		}

		Loop = 1;
		step = 1;

		while(Loop)
		{
			switch (step)
			{

			case 1:
				status = CardReset(nbuf, &len, 1);
				if(status == MI_OK)
				{
					step++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				test.mode = KEYB;
				//  memset(test.key,0xFF,6);
				// memset(test.rwbuf,0xff,16);
				// memcpy(Keybuf,CardLan.UserIcNo,4);
				// memcpy(Keybuf+4,SnBack,4);
				// DES_CARD(KeyDes,Keybuf,test.key);
				step++;
				break;

			case 3:
				ioctl(mf_fd, WRITE_TYPE, W_CHAR);
				status = write(mf_fd, &test, sizeof(struct card_buf));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 4:
				status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 5:
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Thr +1));
				if(status == MI_OK)
				{
					Sector.SThrOne[4] = Time.year;
					Sector.SThrOne[5] = Time.month;
					Sector.SThrOne[6] = Time.day;
					Sector.SThrOne[8] = Time.hour;
					Sector.SThrOne[9] = Time.min;
					Sector.SThrOne[10] = Time.sec;

					memcpy(receive_buf,Sector.SThrOne,16);
					status = write(mf_fd,receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 6:
				status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Thr +2));
				if(status == MI_OK)
				{

					memcpy(Bufs.intbuf,Sector.SThrTwo+6,2);
					Bufs.i++;
					memcpy(Sector.SThrTwo+6,Bufs.intbuf,2);
					memset(CardLan.ViewMoney,0,sizeof(CardLan.ViewMoney));
					memcpy(CardLan.ViewMoney,Sector.SThrTwo+6,2);
					Sector.SThrTwo[8] = CardLan.EnterExitFlag;
					Sector.SThrTwo[9] = CardLan.StationID;
					Sector.SThrTwo[10] = CardLan.EnterCarCi;
					Sector.SThrTwo[5] = Section.Updown; //
					memcpy(Sector.SThrTwo+11,DevNum.longbuf,4);
					memcpy(receive_buf,Sector.SThrTwo,16);
					status = write(mf_fd,receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 7:
				Loop = 0;
				step = 0;
				break;

			default:
				Loop = 0;
				break;
			}
		}

		if(step == 0)
		{
			Qflag = 0;
			break;
		}
	}
	LEDL(0);
	beepopen(11);

#if DBG_RC500
	printf("WriteFlagRstart = %d\n",step);
#endif

	return(step);
}



/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteFlag (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlag (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	int  ret;
	ShortUnon Bufs;



	while(Loop)
	{
		switch (step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Thr +1));
			if(ret == MI_OK)
			{
				Sector.SThrOne[4] = Time.year;
				Sector.SThrOne[5] = Time.month;
				Sector.SThrOne[6] = Time.day;
				Sector.SThrOne[8] = Time.hour;
				Sector.SThrOne[9] = Time.min;
				Sector.SThrOne[10] = Time.sec;

				memcpy(receive_buf,Sector.SThrOne,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Thr +2));
			if(ret == MI_OK)
			{

				memcpy(Bufs.intbuf,Sector.SThrTwo+6,2);
				Bufs.i++;
				memcpy(Sector.SThrTwo+6,Bufs.intbuf,2);
				memset(CardLan.ViewMoney,0,sizeof(CardLan.ViewMoney));
				memcpy(CardLan.ViewMoney,Sector.SThrTwo+6,2);
				Sector.SThrTwo[8] = CardLan.EnterExitFlag;
				Sector.SThrTwo[9] = CardLan.StationID;
				Sector.SThrTwo[10] = CardLan.EnterCarCi;
				Sector.SThrTwo[5] = Section.Updown; //
				memcpy(Sector.SThrTwo+11,DevNum.longbuf,4);
				memcpy(receive_buf,Sector.SThrTwo,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 4:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}


	if(step != 0)
	{
		step = WriteFlagRstart();
	}
#if DBG_RC500
	printf("WriteFlag = %d\n",step);
#endif

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpCardInfor (HWND hDlg)
- 函数说明 : 充值金额
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpCardInfor (unsigned char type)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	while(Loop)
	{
		switch (step)
		{
		case 1:
			status = TopUpMokey(type);		//
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 2:
			status = WriteFlag();			//
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 3:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpCardInfor = %d\n",step);
#endif
	if(step > 1) step = 0;
	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ReadorRepairCard (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	while(Loop)
	{
		switch (step)
		{
		case 1:								//读卡
			// status = ReadCardInfor();
			// if(status == MI_OK)
			// {
			status = RepairCardInfor();			   //修复
			if(status == MI_OK) step ++;
			else Loop = 0;
			//  }
			//   else
			//  {
			//     Loop = 0;
			//  }
			break;

		case 2:
			status = Permissions(0);				//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 3:
			status = AnalysisSheet(1);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				Loop = 0;
			}
			break;

		case 4:								//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if((Test.i >= HostValue.i)&&(Test.i !=0 ))
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				Loop = 0;
			}
			break;

		case 5:								//扣现金
			status = YesOrNoCiShu();
			if(status == MI_OK) step ++;
			else
			{
				Err_display(18);
				Loop = 0;
			}
			break;

		case 6:
			status = TopUpCardInfor(0);
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 7:
			IncSerId();
			step++;
			break;

		case 8:
			status = SaveCardData(CARD_SPEC_M1_8BIT, CONSUME_MODE_PRESET); //保存数据  定额
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		case 9:
			step = 0;
			Loop = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("ReadorRepairCard = %d\n",step);
#endif
	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char FreeReadorRepairCard(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;
	// unsigned char buff[100],len;

	while(Loop)
	{
		switch (step)
		{
		case 1://读卡
			status = ReadCardInfor();
			if(status == MI_OK) step ++;
			else
			{
				Loop = 0;
			}
			break;

		case 2:
			status = RepairCardInfor();		//修复
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(0); 			//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:
			status = AnalysisSheet(0);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				Loop = 0;
			}
			break;

		case 5: 							//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if((Test.i >= HostValue.i)&&(Test.i !=0 ))
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				Loop = 0;
			}
			break;

		case 6: 							//扣现金
			status = YesOrNoCiShu();
			if(status == MI_OK) step ++;
			else
			{
				Err_display(18);
				Loop = 0;
			}
			break;

		case 7:
			status = TopUpCardInfor(0);
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 8:
			IncSerId();
			step++;
			break;

		case 9:
			status = SaveCardData(CARD_SPEC_M1_8BIT, CONSUME_MODE_FLEXIBLE); //保存数据  定额
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;


		case 10:
			step = 0;
			Loop = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}
	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("FreeReadorRepairCard = %d\n",step);
#endif

	return(step);
}
/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ExitCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	ShortUnon Bufs;

	DBG_RC500_PRINTF("ExitCarProgram() is called.\n");

	while(Loop)
	{
		switch(step)
		{
		case 1:
			status = SectionSheet();
			if(status == MI_OK) step++;
			else if(status == 1)
			{
				Err_display(16);
				Loop = 0;
			}
			else
			{
				Err_display(50);  //没有上车
				Loop = 0;
			}
			break;

		case 2:
			status = AnalysisSheet(0);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				Loop = 0;
			}
			break;

		case 3:
			if(Section.Updoor == 0x02)
			{
				if((CardLan.EnterCarCi == 0)||(CardLan.EnterCarCi >= 100)) CardLan.EnterCarCi = 1;

				HostValue.i = (unsigned int)( HostValue.i * CardLan.EnterCarCi);
				DecValue.i = HostValue.i;
				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段

				}
				//memcpy(Buf.longbuf,Section.DeductMoney,4); //

			}
			else
			{
				CardLan.EnterCarCi = 1;
				DecValue.i = HostValue.i;
				// memcpy(Buf.longbuf,Section.DeductMoney,4); //
				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段
				}
			}

			Buf.i = SectionDiscountRate(Buf.i,CardLan.CardType);

			Buf.i = (unsigned int)( Buf.i * CardLan.EnterCarCi);

			if(Buf.i >= HostValue.i)									//AA增值
			{
				HostValue.i = Buf.i - HostValue.i;
				CardLan.StationDEC = 0xAA;
			}
			else														//55减值
			{
				HostValue.i = HostValue.i - Buf.i;
				CardLan.StationDEC = 0x55;
			}

			memset(Bufs.intbuf,0,sizeof(ShortUnon));
			memcpy(Bufs.intbuf,Sector.SThrTwo+6,2);
			Bufs.i--;
			memcpy(Sector.SThrTwo+6,Bufs.intbuf,2);
			CardLan.StationID= 0;
			CardLan.EnterCarCi = 0;
			CardLan.EnterExitFlag = 0;
			step++;
			break;

		default :
			step =0;
			Loop =0;
			break;
		}
	}

#if  DBG_RC500
	printf("ExitCarProgram = %d\n",step);
#endif


	return step;
}



/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char EnterCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	ShortUnon Bufs;

#if DBG_RC500
	{
		struct timeval now;
		gettimeofday(&now,0);
		DBG_RC500_PRINTF("EnterCarProgram() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif


	while(Loop)
	{
		switch(step)
		{
		case 1:
			// memcpy(HostValue.longbuf,Section.DeductMoney,4);	//预扣金额 分段
			if(Section.Updown)
			{
				memcpy(HostValue.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
			}
			else
			{
				memcpy(HostValue.longbuf,Section.DeductMoney,4);	//预扣金额 分段
			}
			HostValue.i = SectionDiscountRate(HostValue.i,CardLan.CardType);
			step++;
			break;

		case 2:
			memset(Buf.longbuf,0,4);
			memcpy(Buf.longbuf,CardLan.OldTermNo,4);
			if((Buf.i == DevNum.i)&&(Section.SationNow == CardLan.StationID)&&(CardLan.EnterExitFlag == 0x55)&&(Section.Updoor == 0x01))
			{
				status = OverTimeEnter();
				if(status != 0)
				{
					if(CardLan.EnterCarCi >= 100)CardLan.EnterCarCi = 0;
					CardLan.EnterCarCi ++;
					CardLan.EnterExitFlag = 0x55;
					memset(Bufs.intbuf,0,sizeof(ShortUnon));
					memcpy(Bufs.intbuf,Sector.SThrTwo+6,2);
					Bufs.i--;
					memcpy(Sector.SThrTwo+6,Bufs.intbuf,2);
				}
				else
				{
					CardLan.EnterCarCi = 1;
					CardLan.EnterExitFlag = 0x55;
				}
			}
			else
			{
				CardLan.EnterCarCi = 1;
				CardLan.EnterExitFlag = 0x55;
				CardLan.StationID = Section.SationNow;
			}
			step++;
			break;

		default :
			step = 0;
			Loop = 0;
			break;
		}
	}

	return step;
}



/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char SectionFares(void)
{
	unsigned char Loop = 1;
	unsigned char step = 2;
	unsigned char status = 1;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("SectionFares() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif


	CardLan.StationDEC  = 0x55;

	while(Loop)
	{
		switch (step)
		{
			//case 1: 							//读卡
			// status = ReadCardInfor();
			// if(status == MI_OK) step ++;
			//  else
			// {
			//     Loop = 0;
			// }
			//   break;

		case 2:
			status = RepairCardInfor(); 			//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(2); 			//权限
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 4:
			HostValue.i = DecValue.i = 0;
			switch(Section.Updoor)
			{
			case 1:
				status = EnterCarProgram();
				if(status == MI_OK)
				{
					step ++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				if(CardLan.EnterExitFlag == 0x55) 							  //出车
				{
					if(OverTimeEnter() != 0)								  //标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||(Section.SationNow == 1))
						{
							status = ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							Err_display(50);  //没有上车
							Loop = 0;
						}
					}
					else
					{
						Err_display(50);  //没有上车
						Loop = 0;

					}
				}
				else
				{
					Err_display(50);  //没有上车
					Loop = 0;
				}
				break;

			default:
				if(CardLan.EnterExitFlag == 0x55)								//出车
				{
					if(OverTimeEnter() != 0)									//标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||(Section.SationNow == 1))
						{
							status =  ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							status = EnterCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
					}
					else
					{
						status = EnterCarProgram();
						if(status == MI_OK)
						{
							step ++;
						}
						else
						{
							Loop = 0;
						}

					}
				}
				else
				{
					status = EnterCarProgram();
					if(status == MI_OK)
					{
						step ++;
					}
					else
					{
						Loop = 0;
					}
				}
				break;
			}
			break;


		case 5: 							//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if(CardLan.StationDEC ==0x55)
			{
				if((Test.i >= HostValue.i)&&(Test.i !=0 ))
				{
					Sector.FlagValue = 1;
					step++;
				}
				else if(Buf.i >= HostValue.i)
				{
					Sector.FlagValue = 2;
					step++;
				}
				else
				{
					Err_display(12);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
			}
			else
			{
				if(Test.i > 0)
				{
					Sector.FlagValue = 1;
					step++;
				}
				else
				{
					Sector.FlagValue = 2;
					step++;
				}
			}
			break;

		case 6:
			if(CardLan.StationDEC ==0x55)
			{
				status = TopUpCardInfor(0);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			else
			{
				status = TopUpCardInfor(1);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			break;

		case 7:
			status = SaveCardData(CARD_SPEC_M1_8BIT, CONSUME_MODE_SECTIONAL); //保存数据 分段
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("SectionFares = %d\n",step);
#endif
	return(step);
}



#elif  defined(CONFIG_LINUXBUS32BIT)



/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadCardInfor (void)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/

unsigned char ReadCardInfor (void)
{
	static int flag,t,ret;
	static int  receive_len[1] = {0};
	static char receive_buf[20]= {0};
	unsigned char Keybuf[8];
	//  unsigned char i;

	flag = 1;
	t = 2;
	while(flag)
	{
		switch(t)
		{
		case 2:
			test.mode = KEYB;
			memset(test.key,0xFF,6);
			memset(test.rwbuf,0xff,16);
			memcpy(Keybuf,CardLan.UserIcNo,4);
			memcpy(Keybuf+4,SnBack,4);
			DES_CARD(KeyDes,Keybuf,test.key);
			t++;
			break;

		case 3:
			ioctl(mf_fd, WRITE_TYPE, W_CHAR);
			ret = write(mf_fd, &test, sizeof(struct card_buf));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 4:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.One + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 5:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.CityId,  receive_buf,2);
					memcpy(CardLan.AppId,  receive_buf+2,2);
					memcpy(CardLan.CardCsnB,receive_buf+4,4);
					memcpy(CardLan.CardId,receive_buf+8,4);
					CardLan.CardType = receive_buf[12];
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 6:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.One + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(CardLan.EnableH,  receive_buf+4,4);
					memcpy(CardLan.Effective,  receive_buf+8,4);
					memcpy(CardLan.UserWord,  receive_buf+12,3);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 7:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Two + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 8:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 9:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Two+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.STwoTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 10:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Thr + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 11:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 12:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Thr+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SThrTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 13:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.For + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 14:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.For + 1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SForOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 15:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.For + 2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SForTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 16:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)t++;
			else flag = 0;
			break;

		case 17:
			ret = ioctl(mf_fd, RC531_READ,4*LanSec.Fiv);
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivZero,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 18:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv+1));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivOne,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 19:
			ret = ioctl(mf_fd, RC531_READ,(4*LanSec.Fiv+2));
			if(ret == MI_OK)
			{
				ret = ioctl(mf_fd, FIFO_RCV_LEN, receive_len);
				ret = read(mf_fd, receive_buf, receive_len[0]);
				if(ret >= 0)
				{
					memcpy(Sector.SFivTwo,receive_buf,16);
					t++;
				}
				else
				{
					flag = 0;
				}
			}
			else flag = 0;
			break;

		case 20:
			t = MI_OK;
			flag = 0;
			break;

		default:
			flag = 0;
			break;
		}
	}

	return(t);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeThirteen(void)
- 函数说明 : SxB2 -> SxB1
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeThirteen(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	int ret;

	CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
	}
	else if(CardLan.OldTransType == 0x30)
	{
		SectorNum = 4*LanSec.For;
	}
	else
	{
		return 1;
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum+ 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ret = ioctl(mf_fd,RC531_RESTORE,(SectorNum + 2));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd,RC531_TRANSFER,(SectorNum + 1));
			if(ret== MI_OK)step++;
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume 13 = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeTypeSix (void)
- 函数说明 : SxB1 - > SxB2
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeTypeSix(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SectorNum;
	int ret;

	CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
	if(CardLan.OldTransType == 0x10)
	{
		SectorNum = 4*LanSec.Two;
	}
	else if(CardLan.OldTransType == 0x20)
	{
		SectorNum = 4*LanSec.Thr;
	}
	else if(CardLan.OldTransType == 0x30)
	{
		SectorNum = 4*LanSec.For;
	}
	else
	{
		return 1;
	}

	while(Loop)
	{
		switch(step)
		{
		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(SectorNum+ 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ret = ioctl(mf_fd,RC531_RESTORE,(SectorNum + 1));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd,RC531_TRANSFER,(SectorNum + 2));
			if(ret== MI_OK)step++;
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("Resume 10 11 = %d\n",step);
#endif
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ResumeType (unsigned char Mode)
- 函数说明 : 修复卡片信息
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ResumeType (unsigned char Mode)
{
	unsigned char status = 1;

	switch(Mode)
	{
	case 10://将SxB1的数据复制到SxB2中
	case 11:
		status = ResumeTypeSix();
		break;

	case 13:
		status = ResumeTypeThirteen();
		break;

	default :
		break;
	}

	return(status);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char CheckSXB1ORSXB2 (void)
- 函数说明 : SXB1 == SXB0
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char CheckSXB1ORSXB2(void)
{
	unsigned char i;
	unsigned char status = 1;
	for(i = 0; i < 16; i++)
	{
		if(XFBuf1[i] != XFBuf2[i]) break;
	}
	if(i == 16) status = 0;
	return(status);
}


/*OK
*************************************************************************************************************
- 函数名称 : unsigned char RepairCardInfor (void)
- 函数说明 : 修复卡片信息
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char RepairCardInfor (void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;
	while(Loop)
	{
		switch (step)
		{
		case 1:							//有效日期是否可行
			status = Card_JudgeDate();
			if(status == MI_OK)
			{
				step++;
			}
			else
			{
				Err_display(1);
				Loop = 0;
			}
			break;

		case 2:
			CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
			if(CardLan.OldTransType == 0x10) 			//次数
			{
				memcpy(XFBuf1,Sector.STwoOne,16);
				memcpy(XFBuf2,Sector.STwoTwo,16);
			}
			else if(CardLan.OldTransType == 0x20) 			//补贴
			{
				memcpy(XFBuf1,Sector.SThrOne,16);
				memcpy(XFBuf2,Sector.SThrTwo,16);
			}
			else
			{
				memcpy(XFBuf1,Sector.SForOne,16);
				memcpy(XFBuf2,Sector.SForTwo,16);
			}
			step++;
			break;

		case 3:
			status = MoneyYes(XFBuf1);				//XFBuf1
			if(status == MI_OK) step++;
			else
			{
				status = MoneyYes(XFBuf2);				//XFBuf1
				if(status == MI_OK)
				{
					status = ResumeType(13);
					if(status == MI_OK) step = 0;
					Loop = 0;

				}
				else
				{
					Err_display(4);
					Loop = 0;
				}
			}
			break;

		case 4:
			status = MoneyYes(XFBuf2);				//XFBuf2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(10);
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		case 5:
			status = CheckSXB1ORSXB2();				//SXB2
			if(status == MI_OK) step++;
			else
			{
				status = ResumeType(11);
				if(status == MI_OK) step = 0;
				Loop = 0;
			}
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

	if(step == 0)
	{
		memcpy(CardLan.Views, Sector.STwoOne, 4);
		memcpy(CardLan.Subsidies, Sector.SThrOne,4);
		memcpy(CardLan.QCash, Sector.SForOne,4);


		memcpy(CardLan.OldTermNo,Sector.SFivZero+6,4);
		//
		CardLan.StationOn = Sector.SFivZero[11];   //分段收费序号
		CardLan.StationOn = Sector.SFivZero[12];   //卡组
		CardLan.EnterCarCi = Sector.SFivZero[13];
		CardLan.OldTransType = Sector.SFivZero[14] & 0xf0;
		CardLan.StationID= Sector.SFivZero[15];

		memcpy(CardLan.OldTime,Sector.SFivOne,6);
		CardLan.Period = Sector.SFivOne[6];
		CardLan.EnterExitFlag = Sector.SFivOne[11];//进出标志

		memcpy(CardLan.ViewsValue, Sector.SFivTwo, 3);
		memcpy(CardLan.DayValue,   Sector.SFivTwo+4, 3);
		memcpy(CardLan.MonthValue, Sector.SFivTwo+8, 4);
	}

#if DBG_RC500
	printf("RepairCardInforstep = %d\n",step);
#endif

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpMokey (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpMokey (unsigned char type)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SetorNum;
	int status;

	if(Sector.FlagValue == 0)
	{
		SetorNum = 4*LanSec.Two;
	}
	else if(Sector.FlagValue == 1)
	{
		SetorNum = 4*LanSec.Thr;
	}
	else
	{
		SetorNum = 4*LanSec.For;
	}

	memcpy(test.money,HostValue.longbuf,4);


	while(Loop)
	{
		switch (step)
		{

		case 1:
			ioctl(mf_fd, WRITE_TYPE,W_CHAR);
			status = write(mf_fd,&test,sizeof(struct card_buf));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			status = ioctl(mf_fd, RC531_AUTHENT,(SetorNum + 3));
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 3:
			if(type == 0)
			{
				status = ioctl(mf_fd, RC531_DEC,SetorNum+1);
				if(status == MI_OK)step++;
				else Loop = 0;
			}
			else {
				status = ioctl(mf_fd, RC531_INC,SetorNum+1);
				if(status == MI_OK)step++;
				else Loop = 0;

			}
			break;

		case 4:
			status = ioctl(mf_fd,RC531_RESTORE,(SetorNum + 1));//只读信息区域
			if(status == MI_OK)step++;
			else Loop = 0;
			break;

		case 5:
			status = ioctl(mf_fd,RC531_TRANSFER,(SetorNum + 2));//只读信息区域
			if(status== MI_OK)step++;
			else Loop = 0;
			break;

		case 6:
			Loop = 0;
			step = 0;
			break;

		default:
			Loop = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpMokey = %d\n",step);
#endif

	if(step > 3) step = 0;

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteS5B0DatTwo (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlagRstart(void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char Qflag = 1;
	unsigned char Xor,i;
	unsigned char Keybuf[8],Timebuf[8];
	unsigned char nbuf[20],len,ic=0;
	unsigned char SECTOR;
	int status = 1;
	ShortUnon Bufs;



	SetColor(Mcolor);
	SetTextColor(Color_red);
	SetTextSize(32);
	TextOut(100 , 50, "温馨提示");
	TextOut(100 , 90, "刷卡错误");
	TextOut(85  , 130,"请重新刷卡");

	LEDL(1);
	beepopen(10);
	PlayMusic(15);

	while(Qflag)
	{
		Rd_time (Timebuf+1);
		if(Time.sec != Timebuf[6])
		{
			Timebuf[0] = 0x20;
			Time.year = Timebuf[1];
			Time.month = Timebuf[2];
			Time.day = Timebuf[3];
			Time.hour = Timebuf[4];
			Time.min = Timebuf[5];
			Time.sec = Timebuf[6];

			ic++;
			if(ic>30)
			{
				Qflag =0;
				break;
			}

			if((ic>2)&&(ic%3 == 0))
			{
				PlayMusic(15);
			}
		}

		Loop = 1;
		step = 1;

		while(Loop)
		{
			switch (step)
			{

			case 1:
				status = CardReset(nbuf, &len, 1);
				if(status == MI_OK)
				{
					step++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				test.mode = KEYB;
				//  memset(test.key,0xFF,6);
				// memset(test.rwbuf,0xff,16);
				// memcpy(Keybuf,CardLan.UserIcNo,4);
				// memcpy(Keybuf+4,SnBack,4);
				// DES_CARD(KeyDes,Keybuf,test.key);
				step++;
				break;

			case 3:
				ioctl(mf_fd, WRITE_TYPE, W_CHAR);
				status = write(mf_fd, &test, sizeof(struct card_buf));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 4:
				status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 5:
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
				if(status == MI_OK)
				{
					memcpy(receive_buf,Sector.SFivZero,16);
					status = write(mf_fd,receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 6:
				status = ioctl(mf_fd, RC531_WRITE, 4*LanSec.Fiv+1);
				if(status == MI_OK)
				{
					memcpy(receive_buf,Sector.SFivOne,16);
					status = write(mf_fd,receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 7:
				status = ioctl(mf_fd, RC531_WRITE, 4*LanSec.Fiv+2);
				if(status == MI_OK)
				{
					memcpy(receive_buf,Sector.SFivTwo,16);
					status = write(mf_fd,receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 8:
				status = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Six + 3));
				if(status == MI_OK)step++;
				else Loop = 0;
				break;

			case 9:
				SECTOR = Sector.SFivTwo[12]-1;
				if(SECTOR > 2) SECTOR = 0;
				ioctl(mf_fd, WRITE_TYPE,W_CARD);
				status = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Six+SECTOR));
				if(status == MI_OK)
				{
					receive_buf[0] = Time.day;
					receive_buf[1] = Time.hour;
					receive_buf[2] = Time.min;
					receive_buf[3] = Time.sec;

					if(Sector.FlagValue == 0)
					{
						memcpy(receive_buf+4,CardLan.Views,4);
					}
					else if(Sector.FlagValue == 1)
					{
						memcpy(receive_buf+4,CardLan.Subsidies,4);
					}
					else if(Sector.FlagValue == 2)
					{
						memcpy(receive_buf+4,CardLan.QCash,4);
					}
					else
					{
						memcpy(receive_buf+4,"\x00\x00\x00\x00",4);
					}
					memcpy(receive_buf+8,HostValue.longbuf,3);
					receive_buf[11] = ((Sector.FlagValue+1)<<4)|0x03;
					memcpy(receive_buf+12,DevNum.longbuf,4);
					status = write(mf_fd, receive_buf,16);
					if(status == MI_OK)step++;
					else Loop = 0;
				}
				else Loop = 0;
				break;

			case 10:
				Loop = 0;
				step = 0;
				break;

			default:
				Loop = 0;
				break;
			}
		}

		if(step == 0)
		{
			Qflag = 0;
			break;
		}
	}
	LEDL(0);
	beepopen(11);

#if DBG_RC500
	printf("WriteFlagRstart = %d\n",step);
#endif

	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char WriteFlag (void)
- 函数说明 :
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char WriteFlag (void)
{
	static char receive_buf[20]= {0};
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char SECTOR;
	int  ret;
	LongUnon Bufc;

	memcpy(Sector.SFivZero+6, DevNum.longbuf,4);
	Sector.SFivZero[12] = Section.Updown; //
	Sector.SFivZero[13] = CardLan.EnterCarCi;
	Sector.SFivZero[14] = ((Sector.FlagValue+1)<<4)|0x03; //上次交易类型
	Sector.SFivZero[15] = CardLan.StationID;

	memcpy(Sector.SFivOne,&Time,6);
	Sector.SFivOne[6] = TypeTime.TimeNum;
	Sector.SFivOne[11] = CardLan.EnterExitFlag;

	if((++Sector.SFivTwo[12]) > 3)
		Sector.SFivTwo[12] = 1;


	SECTOR = Sector.SFivTwo[12]-1;
	if(SECTOR > 2) SECTOR = 0;

	memset(Bufc.longbuf,0,sizeof(LongUnon));
	memcpy(Bufc.longbuf,Sector.SFivTwo+13,3);
	Bufc.i ++;
	memcpy(Sector.SFivTwo+13,Bufc.longbuf,3);
	memcpy(CardLan.ViewMoney,Bufc.longbuf,4);


	while(Loop)
	{
		switch (step)
		{

		case 1:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Fiv + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 2:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,4*LanSec.Fiv);
			if(ret == MI_OK)
			{
				memcpy(receive_buf,Sector.SFivZero,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 3:
			ret = ioctl(mf_fd, RC531_WRITE, 4*LanSec.Fiv+1);
			if(ret == MI_OK)
			{
				memcpy(receive_buf,Sector.SFivOne,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 4:
			ret = ioctl(mf_fd, RC531_WRITE, 4*LanSec.Fiv+2);
			if(ret == MI_OK)
			{
				memcpy(receive_buf,Sector.SFivTwo,16);
				ret = write(mf_fd,receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		case 5:
			ret = ioctl(mf_fd, RC531_AUTHENT,(4*LanSec.Six + 3));
			if(ret == MI_OK)step++;
			else Loop = 0;
			break;

		case 6:
			ioctl(mf_fd, WRITE_TYPE,W_CARD);
			ret = ioctl(mf_fd, RC531_WRITE,(4*LanSec.Six+SECTOR));
			if(ret == MI_OK)
			{
				receive_buf[0] = Time.day;
				receive_buf[1] = Time.hour;
				receive_buf[2] = Time.min;
				receive_buf[3] = Time.sec;

				if(Sector.FlagValue == 0)
				{
					memcpy(receive_buf+4,CardLan.Views,4);
				}
				else if(Sector.FlagValue == 1)
				{
					memcpy(receive_buf+4,CardLan.Subsidies,4);
				}
				else if(Sector.FlagValue == 2)
				{
					memcpy(receive_buf+4,CardLan.QCash,4);
				}
				else
				{
					memcpy(receive_buf+4,"\x00\x00\x00\x00",4);
				}
				memcpy(receive_buf+8,HostValue.longbuf,3);
				receive_buf[11] = ((Sector.FlagValue+1)<<4)|0x03;
				memcpy(receive_buf+12,DevNum.longbuf,4);
				ret = write(mf_fd, receive_buf,16);
				if(ret == MI_OK)step++;
				else Loop = 0;
			}
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

	if(step != 0)
	{
		step = WriteFlagRstart();
	}

#if DBG_RC500
	printf("WriteFlag = %d\n",step);
#endif

	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char TopUpCardInfor (HWND hDlg)
- 函数说明 : 充值金额
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char TopUpCardInfor (unsigned char type)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status;

	while(Loop)
	{
		switch (step)
		{

		case 1:
			status = TopUpMokey(type);			// 扣钱
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 2:
			status = WriteFlag();			//写卡交易记录
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		default:
			Loop = 0;
			step = 0;
			break;
		}
	}

#if DBG_RC500
	printf("TopUpCardInfor = %d\n",step);
#endif
	if(step >1) step = 0;
	return(step);
}

/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char ReadorRepairCard (void)
{
	unsigned char Loop = 1;
	unsigned char step = 2;
	unsigned char status;
	unsigned char FlagM = 0;

	BFlaglessfive = 0;
	while(Loop)
	{
		switch (step)
		{
		case 1:								//读卡
			step ++;
			break;

		case 2:
			status = RepairCardInfor();				//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(0);				//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:	//扣次
			memcpy(JackArm.longbuf,CardLan.Views,4);
			if(JackArm.i > 0)
			{
				HostValue.i = DecValue.i = 1;
				Sector.FlagValue = 0;
				FlagM = YesOrNoCiShu();
				if(FlagM != 0)step++;
				else
				{
					step = 8;
				}
			}
			else step++;
			break;

		case 5:
			status = AnalysisSheet(1);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 6:								//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);

#if DBG_RC500
			printf("CardLan.Subsidies = %d\n", Test.i);
			printf("CardLan.QCash = %d\n", Buf.i);
			printf("HostValue.i = %d\n", HostValue.i);
#endif


			if((Test.i >= HostValue.i)&&(Test.i != 0))
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 7:								//扣现金
			status = YesOrNoMoney();
			if(status == MI_OK) step ++;
			else if(status == 0x01)					//超过时段消费金额
			{
				Err_display(13);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else if(status == 0x02)					//超过今天消费金额
			{
				Err_display(14);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else							//超过当月消费金额
			{
				Err_display(15);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 8:
			status = TopUpCardInfor(0);
			if(status == MI_OK)
			{
				step++;
				IncSerId();
			}
			else Loop = 0;
			break;

		case 9:
			status = SaveCardData(CARD_SPEC_M1_32BIT, CONSUME_MODE_PRESET); //保存数据  定额
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}
	ioctl(mf_fd, RC531_HALT);
	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("ReadorRepairCard = %d\n",step);
#endif
	return(step);
}


/*
*************************************************************************************************************
- 函数名称 : unsigned char ReadorRepairCard (HWND hDlg,int mode)
- 函数说明 : 用户卡读及修复卡片
- 输入参数 : 无
- 输出参数 : 无
*************************************************************************************************************
*/
unsigned char FreeReadorRepairCard(void)
{
	unsigned char Loop = 1;
	unsigned char step = 1;
	unsigned char status = 1;

	BFlaglessfive = 0;
	while(Loop)
	{
		switch (step)
		{
		case 1:								//读卡
			status = ReadCardInfor();
			if(status == MI_OK) step ++;
			else
			{
				Loop = 0;
			}
			break;

		case 2:
			status = RepairCardInfor();				//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(0);				//权限
			if(status == MI_OK) step ++;
			else Loop = 0;
			break;

		case 4:
			status = AnalysisSheet(0);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 5:								//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if(Test.i >= HostValue.i)
			{
				Sector.FlagValue = 1;
				step++;
			}
			else if(Buf.i >= HostValue.i)
			{
				if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
				Sector.FlagValue = 2;
				step++;
			}
			else
			{
				Err_display(12);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 6:								//扣现金
			status = YesOrNoMoney();
			if(status == MI_OK) step ++;
			else if(status == 0x01)					//超过时段消费金额
			{
				Err_display(13);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else if(status == 0x02)					//超过今天消费金额
			{
				Err_display(14);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			else							//超过当月消费金额
			{
				Err_display(15);
				ioctl(mf_fd, RC531_HALT);
				Loop = 0;
			}
			break;

		case 7:
			status = TopUpCardInfor(0);
			if(status == MI_OK)
			{
				step++;
				IncSerId();
			}
			else Loop = 0;
			break;

		case 8:
			status = SaveCardData(CARD_SPEC_M1_32BIT, CONSUME_MODE_FLEXIBLE); //保存数据 自由
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("FreeReadorRepairCard = %d\n",step);
#endif
	return(step);
}




unsigned char ExitCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	LongUnon Bufc;

	DBG_RC500_PRINTF("ExitCarProgram() is called.\n");

	while(Loop)
	{
		switch(step)
		{
		case 1:
			status = SectionSheet();
			if(status == MI_OK) step++;
			else if(status == 1)
			{
				Err_display(16);
				Loop = 0;
			}
			else
			{
				Err_display(50);  //没有上车
				Loop = 0;
			}
			break;

		case 2:
			status = AnalysisSheet(0);				//查消费表
			if(status == MI_OK) step ++;
			else
			{
				Err_display(16);
				Loop = 0;
			}
			break;

		case 3:
			if(Section.Updoor == 0x02)
			{
				if((CardLan.EnterCarCi == 0)||(CardLan.EnterCarCi >= 100)) CardLan.EnterCarCi = 1;

				HostValue.i = (unsigned int)( HostValue.i * CardLan.EnterCarCi);
				DecValue.i = HostValue.i;
				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段
				}
				// memcpy(Buf.longbuf,Section.DeductMoney,4); //

			}
			else
			{
				CardLan.EnterCarCi = 1;
				DecValue.i = HostValue.i;
				if(CardLan.StationOn)
				{
					memcpy(Buf.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
				}
				else
				{
					memcpy(Buf.longbuf,Section.DeductMoney,4);	//预扣金额 分段

				}
				// memcpy(Buf.longbuf,Section.DeductMoney,4); //
			}

			Buf.i = SectionDiscountRate(Buf.i,CardLan.CardType);

			Buf.i = (unsigned int)( Buf.i * CardLan.EnterCarCi);

			if(Buf.i >= HostValue.i)									//AA增值
			{
				HostValue.i = Buf.i - HostValue.i;
				CardLan.StationDEC = 0xAA;
			}
			else														//55减值
			{
				HostValue.i = HostValue.i - Buf.i;
				CardLan.StationDEC = 0x55;
			}
			memset(Bufc.longbuf,0,sizeof(LongUnon));
			memcpy(Bufc.longbuf,Sector.SFivTwo+13,3);
			Bufc.i --;
			memcpy(Sector.SFivTwo+13,Bufc.longbuf,3);
			CardLan.StationID= 0;
			CardLan.EnterCarCi = 0;
			CardLan.EnterExitFlag = 0;
			step++;
			break;

		default :
			step =0;
			Loop =0;
			break;
		}
	}

#if  DBG_RC500
	printf("ExitCarProgram = %d\n",step);
#endif


	return step;
}




unsigned char EnterCarProgram(void)
{
	unsigned char step = 1;
	unsigned char Loop = 1;
	unsigned char status;
	LongUnon Bufc;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("EnterCarProgram() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif

	while(Loop)
	{
		switch(step)
		{
		case 1:
			//  memcpy(HostValue.longbuf,Section.DeductMoney,4);	//预扣金额 分段
			if(Section.Updown)
			{
				memcpy(HostValue.longbuf,Sectionup.DeductMoney,4);	//预扣金额 分段
			}
			else
			{
				memcpy(HostValue.longbuf,Section.DeductMoney,4);	//预扣金额 分段
			}
			HostValue.i = SectionDiscountRate(HostValue.i,CardLan.CardType);
			step++;
			break;

		case 2:
			memset(Buf.longbuf,0,4);
			memcpy(Buf.longbuf,CardLan.OldTermNo,4);
			if((Buf.i == DevNum.i)&&(Section.SationNow == CardLan.StationID)&&(CardLan.EnterExitFlag == 0x55)&&(Section.Updoor == 0x01)&&(CardLan.StationOn == Section.Updown))
			{
				status = OverTimeEnter();
				if(status != 0)
				{
					if(CardLan.EnterCarCi >= 100)CardLan.EnterCarCi = 0;
					CardLan.EnterCarCi ++;
					CardLan.EnterExitFlag = 0x55;

					memset(Bufc.longbuf,0,sizeof(LongUnon));
					memcpy(Bufc.longbuf,Sector.SFivTwo+13,3);
					Bufc.i --;
					memcpy(Sector.SFivTwo+13,Bufc.longbuf,3);
				}
				else
				{
					CardLan.EnterCarCi = 1;
					CardLan.EnterExitFlag = 0x55;
				}
			}
			else
			{
				CardLan.EnterCarCi = 1;
				CardLan.EnterExitFlag = 0x55;
				CardLan.StationID = Section.SationNow;
			}
			step++;
			break;

		default :
			step = 0;
			Loop = 0;
			break;
		}
	}

	return step;
}

//SectionSheet
unsigned char SectionFares(void)
{
	unsigned char Loop = 1;
	unsigned char step = 2;
	unsigned char status = 1;

#if DBG_RC500
	{
		struct timeval now;

		gettimeofday(&now,0);
		DBG_RC500_PRINTF("SectionFares() is called, time = %ld\"%06ld.\n", now.tv_sec, now.tv_usec);
	}
#endif


	CardLan.StationDEC  = 0x55;

	while(Loop)
	{
		switch (step)
		{
		case 1: 							//读卡
			// status = ReadCardInfor();
			// if(status == MI_OK) step ++;
			//  else
			// {
			//     Loop = 0;
			// }
			step++;
			break;

		case 2:
			status = RepairCardInfor(); 			//修复
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 3:
			status = Permissions(2); 			//权限
			if(status == MI_OK) step++;
			else Loop = 0;
			break;

		case 4:
			HostValue.i = DecValue.i = 0;
			switch(Section.Updoor)
			{
			case 1:
				status = EnterCarProgram();
				if(status == MI_OK)
				{
					step ++;
				}
				else
				{
					Loop = 0;
				}
				break;

			case 2:
				if(CardLan.EnterExitFlag == 0x55) 							  //出车
				{
					if(OverTimeEnter() != 0)								  //标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||(Section.SationNow == 1))
						{
							status = ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							Err_display(50);  //没有上车
							Loop = 0;
						}
					}
					else
					{
						Err_display(50);  //没有上车
						Loop = 0;

					}
				}
				else
				{
					Err_display(50);  //没有上车
					Loop = 0;
				}
				break;

			default:
				if(CardLan.EnterExitFlag == 0x55)								//出车
				{
					if(OverTimeEnter() != 0)									//标志是属于出车，但考虑到上次没打卡下车现象，超出这个时间
					{	//还是当进车处理,终端机号不对当进车处理
						if(((CardLan.StationID<= SectionNum)&&(CardLan.StationID != 0))||(Section.SationNow == 1))
						{
							status =  ExitCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
						else
						{
							status = EnterCarProgram();
							if(status == MI_OK)
							{
								step ++;
							}
							else
							{
								Loop = 0;
							}
						}
					}
					else
					{
						status = EnterCarProgram();
						if(status == MI_OK)
						{
							step ++;
						}
						else
						{
							Loop = 0;
						}

					}
				}
				else
				{
					status = EnterCarProgram();
					if(status == MI_OK)
					{
						step ++;
					}
					else
					{
						Loop = 0;
					}
				}
				break;
			}
			break;


		case 5: 							//扣现金
			memcpy(Test.longbuf,CardLan.Subsidies,4);
			memcpy(Buf.longbuf,CardLan.QCash,4);
			if(CardLan.StationDEC == 0x55)
			{
				if((Test.i >= HostValue.i)&&(Test.i !=0 ))
				{
					Sector.FlagValue = 1;
					step++;
				}
				else if(Buf.i >= HostValue.i)
				{
					if(Buf.i <= HostValue.i*5) BFlaglessfive = 1;
					Sector.FlagValue = 2;
					step++;
				}
				else
				{
					Err_display(12);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
			}
			else
			{
				if(CardLan.OldTransType == 0x10)
				{
					Sector.FlagValue = 0;
				}
				else if(CardLan.OldTransType == 0x20)
				{
					Sector.FlagValue = 1;
				}
				else
				{
					Sector.FlagValue = 2;
				}
				step++;
			}
			break;

		case 6: 							//扣现金
			if(CardLan.StationDEC == 0x55)
			{
				status = YesOrNoMoney();
				if(status == MI_OK) step ++;
				else if(status == 0x01) 				//超过时段消费金额
				{
					Err_display(13);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
				else if(status == 0x02) 				//超过今天消费金额
				{
					Err_display(14);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
				else							//超过当月消费金额
				{
					Err_display(15);
					ioctl(mf_fd, RC531_HALT);
					Loop = 0;
				}
			}
			else
			{
				step++;
			}
			break;

		case 7:
			if(CardLan.StationDEC ==0x55)
			{
				status = TopUpCardInfor(0);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			else
			{
				status = TopUpCardInfor(1);
				if(status == MI_OK)
				{
					step++;
					IncSerId();
				}
				else Loop = 0;
			}
			break;

		case 8:
			status = SaveCardData(CARD_SPEC_M1_32BIT, CONSUME_MODE_SECTIONAL); //保存数据 分段
			if(status == MI_OK) step ++;
			else
			{
				Err_display(20);
				Loop = 0;
			}
			AutoUpFlag = 0x55;
			break;

		default:
			step = 0;
			Loop = 0;
			break;
		}
	}

	ioctl(mf_fd, RC531_HALT);

#if DBG_RC500
	printf("SectionFares = %d\n",step);
#endif
	return(step);
}

#endif






















